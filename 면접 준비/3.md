# 안드로이드 필수 질문

## 기본

1. AAPT?
   AAPT는 Android Asset Package Tool의 약자이다. 이것은 패키징 프로세스를 다룬다. 안드로이드 빌드 툴의 일부로 SDK안에 포함되어 있다. 빌드 과정에서는 안드로이드 앱의 소스를 제회한 나머지 파일을 정리하여 apk로 패키징 하는데 쓰인다. R.java파일은 안드로이드 프로젝트에서 사용되는 리소스 들에 대한 액세스를 간편하게 해 주기 위해 자동으로 생성되는 소스 파일이다. 이 파일을 생성하기 위해서는 appt툴을 이용한다.

2. NDK?

   NDK는 Native Developmet Kit의 약자이며, Android 앱에C 또는 C++(“네이티브 코드”)를 삽입할 수 있게 해주는 도구 집합이다.

3. ANR?

   ANR(Application Not Responding) 어플리케이션이 응답하지 않는다는 에러이다.

   아래와 같은 상황에 ANR이 발생한다.

   응용 프로그램이 5초 이상 사용자의 입력에 반응하지 않을 때

   브로드캐스트 리시버가 10초 내로 리턴하지 않을 때

   아래와 같은 방법으로 예방 할 수 있다.

   onCreate()나 onResume()같은 핵심 생명주기 메소드에서는 가장 적은일을 수행해야 한다.

   시간 소모가 많은 작업은 스레드를 통해 처리한다.

   사용자에게 프로그레스바 등을 이용해 작업의 진행 과정을 안내해 기다리도록 한다.

4. 빌드, 컴파일 설명

5. 컴파일 타임, 런 타임 설명 -> 대답 못함, 컴파일 되는 중, 실행 되는 중 밖에 모르겠다.

6. ADB?

   ADB는 Android Debug Bridge의 약자로 Android를 위한 Debugging Tool이다. 이 도구는 앱 설치 및 디버깅과 같은 다양한 기기 작업을 쉽게 해주고, 에뮬레이터나 연결된 기기에서 다양한 명령을 실행하는데 사용할 수 있는 Unix 셸 액세스를 제공한다.

7. 안드로이드 4대 컴포넌트 설명

   액티비티

   액티비티는 사용자 인터페이스가 있는 단일화면을 나타낸다. 하나 이상의 view를 가질 수 있다. 다른 어플리케이션의 액티비티에 접근하는 것도 가능하다.

   서비스

   서비스는 백그라운드에서 실행되는 컴포넌트이다. 보통 오랜 시간이 걸리는 작업, 원격 프로세스를 위한 작업, 계속 실행해야하는 작업을 할 때 사용 된다.

   한번 시작된 서비스는 어플리케이션이 종료되어도 백그라운드에서 실행된다.

   브로드캐스트 리시버

   브로드캐스트 수신자는 안드로이드에서 디바이스에서 발생하는 이벤트 및 정보를 받을 수 있게 하는 컴포넌트이다. 전화 및 수신, 네트워크 끊김과 같은 정보를 안드로이드 OS에서 어플리케이션으로 방송해주는데, 이를 받기 위해 사용된다.

   콘텐트 프로바이더

   콘텐트 프로바이더는 데이터를 관리하고, 다른 어플리케이션의 데이터를 받을 수 있는 컴포넌트이다.

   파일 입출력, SQLite, DB, Web등을 통하여 데이터를 관리 할 수 있다. 어플리케이션 계층과 데이터 계층을 분리하여 중간 가교 역할을 담당한다. 어플리케이션은 콘텐트 프로바이더에 접근하면, 필요한 데이터를 얻어 올 수 있다.

8. Android Application의 구조?

   manifest

   안드로이드 어플리케이션을 구동하는데 필요한 설정값을 관리해주는 곳이다.

   java

   클래스들을 관리하는 폴더이다.

   res

   UI와 관련된 파일과 디자인 리소스 문자열 리소스를 담고 있는 폴더이다.

   drawable : 이미지 파일 저장

   mipmap : 아이콘 이미지 저장

   value : 문자열, 색상값, 수치값, 스타일 저장

   gradle

   build tool 이다. 안드로이드 스튜디오는 코드 편집만을 담당할 뿐, 빌드는 Gradle을 통해 모두 수행 된다.

   참고

9. 컨텍스트란?

   어플리케이션 환경에 관한 글로벌 정보를 접근하기 위한 인터페이스. Abstract 클래스이며 실재 구현은 안드로이드 시스템에 의해 제공된다. Context 를 통해, 어플리케이션에 특화된 리소스나 클래스에 접근할 수 있을 뿐만 아니라, 추가적으로, 어플리케이션 레벨의 작업 - Activity 실행, Intent 브로드캐스팅, Intent 수신 등, 을 수행하기 위한 API 를 호출 할 수도 있다.

   Application Context

   실행 중인 안드로이드 어플리케이션의 Singleton Instance이다.

   Activity/Service Context

   Activity와 Service는 보인 그자체가 Context이다. Activity와 Service 모두 ContextWrapper를 상속 받는다. Activity Context인 경우 자신의 뷰 컴포넌트를 관리하기 위해 Application Context가 아닌, 자신의 Activity Context에 접근해야 한다. "this" 키워드를 이용해서 가능하다.

10. AndroidManifest.xml 이란?

    AndroidManifest.xml은 안드로이드 어플리케이션에 대한 각종 정보를 기술한 어플리케이션 명세서 라고 할 수 있다. AndroidManifest.xml에 기술되는 내용은 다음과 같다.

    안드로이드 어플리케이션을 위한 자바 패키지명 정의 이 패키지 명은 전체 시스템 상으로 유일 해야한다.

    안드로이드 어플리케이션을 구성하는 컴포넌트들 (Activity, Service, Broadcast Receiver, Content Provider)을 기술 해야 한다.

    <activity>, <service>, <receiver>,<provider>

    어플리케이션을 구성하는 컴포넌트들에 대한 해당 클래스명을 정의하고, 그 컴포넌트가 처리할 수 있는 기능이 무엇인지 intent-filler을 통해 정의 한다.

    <intent-filter>

    안드로이드 어플리케이션이 안드로이드 플랫폼의 제한된 API에 접근하거나 다른 어플리케이션의 제한된 컴포넌트를 사용하기 위해서 필요한 권한을 설정한다.

    <uses-permission>

    안드로이드 어플리케이션은 자신의 Component를 쉽게 사용할 수 없도록 권한을 설정할 수 있다.

    <permission>

    안드로이드 어플리케이션을 구동하기 위한 최소한의 sdk버전을 정의

    <uses-sdk>

    안드로이드 어플리케이션이 사용하는 다른 추가적인 라이브러리들을 정의

    <uses-library>

11. Application 클래스 란?

    안드로이드에서 Application Class란 어플리케이션 컴포넌트들 사이에서 공동으로 멤버들을 사용할 수 있게 해주는 편리한 공유 클래스이다. 어플리케이션 사이의 컴포넌트들이 공동으로 사용할 수 있기 때문에 공통되게 사용하는 내용을 작성해주면 어디서든 context를 이용한 접근이 가능하다.

    사용방법은 아래와 같다.

    Application class를 상속받는다.

    AndroidManifest.xml에 Applicatgion Class Name을 추가한다.

    어플리케이션 내의 컴포넌트들 사이에서 context를 이용한 접근이 가능하다. (데이터 공유)

12. 안드로이드의 4대 컴포넌트에 대해서 설명해보세요.

    안드로이드의 4대 컴포넌트로는 액티비티, 서비스, 브로드캐스트리시버, 콘텐트 프로바이더가 있습니다.(액서브콘)

    액티비티는 안드로이드에서 화면을 관리하고 사용자의 다양한 이벤트를 처리하는데 사용됩니다.

    서비스는 화면에서 보이지 않지만 특정한 기능을 백그라운드에서 처리하는데 사용됩니다.

    브로드캐스트 리시버는 안드로이드에서 발생하는 특정 브로트캐스트 메세지를 처리하기 위한 컴포넌트입니다.

    콘텐트 프로바이더는 앱 사이의 데이터의 공유를 위한 인터페이스를 제공하는 컴포넌트입니다.

13. 안드로이드 매니페스트 파일

    매니페스트 파일은 앱의 이름, 버전, 구성요소, 권한등 앱의 실행에서 꼭 필요한 정보가 저장되어 있는 파일입니다.
    xml파일로 프로젝트의 최상위에 존재합니다.

    태그 구성으로 가장 위는 manifest태그가 존재하고 패키지명, 버전 등이 기제됩니다.

    application태그에는 앱 아이콘, 앱 이름등의 정보가 저장됩니다.

    activity태그에는 액티비티 클래스명과 액티비티 이름을 정의합니다.
    activity하위에는 intent-filter태그를 이용하여 엑티비티에 대한 인텐트 작업시 필요한 action과 category를 정의합니다.

    service,receiver,provider 태그에는 서비스,리시버,프로바이더에 대한 내용이 정의되어 있습니다.

    permission태그에는 앱에서 필요한 권한을 정의합니다.

    그밖에 sdk버전을 지칭하는 uses-sdk와 다른 패키지를 등록할 수 있는 uses-library등이 존재합니다.

    안드로이드 매니페스트는 앱의 이름, 버전, 구성요소, 권한 등 앱의 실행에 있어서 필요한 각종 정보가 저장되어있는 파일입니다. 반드시 존재해야하는 xml 형식의 파일로 안드로이드 프로젝트의 최상위에 위치하고 있습니다.

    가장 최상위는 manifest 태그가 위치하고 있습니다. manifest 태그에는 패키지명, 앱 버전 코드, 앱 버전 이름을 정의합니다.

    application 태그에는 앱 아이콘, 앱 이름을 정의합니다.

    activity 태그에는 액티비티의 클래스명과 액티비티 이름을 정의합니다. 하위에는 intent-filter 태그를 이용하여 액티비티에 대한 인텐트 작업시 필요한 action과 category를 정의합니다.

    service, receiver, provider 태그에는 각각 서비스, 리시버, 프로바이더에 대한 내용을 정의합니다.

    permission 태그에는 앱에서 필요한 권한에 내용을 정의합니다.

    그 밖에 최소 안드로이드 SDK 버전을 지정하는 uses-sdk와 다른 패키지를 등록할 수 있는 uses-library 태그 등이 존재합니다.

14. FCM의 구동 원리? (Firebase Cloud Messaging의 약자)

    본연의 서버의 기능을 수행하면서 또 하나의 복잡한 알림 기능까지 포함한다면 서버의 속도는 처리량이 많아 느려질 것이다. 따라서 이러한 해결책으로 알림의 기능은 다른 서버가 제공을 해주고 본 서버는 알림기능을 제공하는 서버에 알림이 있는지 요청을 해서 정보를 가져오는 구조이다.

    FCM의 동작을 위해서 HTTP나 XMPP로 FCM과 통신하는 서버와 클라이언트 앱이 필요합니다.

    동작 순서

    디바이스에 앱이 설치된후 최초 실행되면서 고유 식별자인 디바이스 토큰이 발급된다. 이 토큰을 앱 서버에 등록한다.

    앱 서버에서 FCM 연결 서버로 푸시 알림을 요청한다. 이때 준비물은 디바이스 토큰과 API 서버 키이다.

    FCM 연결 서버는 토큰을 대상으로 알림 메시지를 푸시한다.

15. 하이브리드 앱이란?

    네이티브 앱처럼 하드웨어의 기능들을 사용할 수 있으며 마켓에 등록이 가능하며 배포 후에도 웹만 연결되어 있다면 수정/보완을 할 수 있습니다. 또한 하나의 소스로 아이폰과 안드로이드에 맞게 포장이 가능하며 핵심 부분은 웹 앱 기술로 빠르게 제작이 가능하여 개발 비용이 적어질 수 있습니다.

    실제 핵심기능은 코드로 구현하고 지속적으로 업데이트 할 부분은 웹에서 관리하는 기능입니다.

16. Looper란 무엇인지 설명해보세요.

    Looper는 스레드간의 신호이므로 handler에 보낸다고 해서 곧바로 처리되는 것이 아닙니다. 동시다발적으로 메세지가 발생할 수 있기 때문에 메세지 큐(Message ueue)에 쌓았다가 처리합니다. 큐(ueue)에 들어있는 내용을 하나하나 꺼내 처리하는 놈이 바로 루퍼입니다. 메인 쓰레드가 looper를 가지고 있으며 무한 루프를 돌며 큐의 내용을 처리합니다.

17. 쓰레드간 통신방법에 대해 설명해보세요.

    - Java IO에서 제공하는 파이프를 이용한 방법
    - 쓰레드간의 공유메모리를 통한 접근 (인스턴스 맴버변수,클래스멤버변수)
    - synchronized를 이용한 시그널링
    - Blockingueue를 이용한 방법

18. 안드로이드 스레드 통신 메커니즘을 알기 위해서는 android.os 패키지 안의 다음 사항을 알아야 한다.

핸들러 - 루퍼 - 메시지 큐 - 메시지
android.os.Looper : UI 스레드에 하나가 존재하며 소비자 스레드와 연관된 메시지 발송자 (데이터를 읽는 역활)
(소비자 => 데이터를 읽는다)

android.os.Handler : 큐에 메시지를 삽입하는 생산자 스레드를 위한 인터페이스와 소비자 스레드 메시지 처리, 하나의 Looper 객체는 많은 핸들러를 갖지만 모두 같은 큐에 삽입
android.os.Messageueue : 소비자 스레드에서 처리할 메시지들이 담긴 무제한의 연결 리스트. 모든 루퍼와 스레드는 최대 하나의 메시지 큐를 가진다.
android.os.Message : 소비자 스레드에서 실행하는 메시지

21. 안드로이드에서 메모리 관리

안드로이드에서 메모리 관리는 GC를 이용해서 진행되게 됩니다.

주기적으로 GC루트에서 모든 객체 참조에 대해 활성객체를 표시하고 활성되지 않은 객체는 메모리에서 지워집니다.

String References와 WeakReference로 나눌 수 있습니다.

22. 안드로이드의 메모리 구조

안드로이드의 메모리구조를 보면 램, 내장메모리, 외장메모리로 구분됩니다.

렘 : 프로그램이 실행될때 상주되는 공간입니다. 평상시에 하드에 저장되어있다가 런타임시에 차지되는 공간을 말합니다.

내장메모리 : 간단하게 하드디스크라고 생각해도 됩니다.

외장메모리 : 메모리가 더 필요할때 추가 할 수 있는 메모리입니다.

안드로이드 HTTP 라이브러리의 역사

2007년 => 안드로이드 발표 , HttpClient, 아파치의 DefaultHttpClient등이 사용
(HttpClient의 여러 버그들 문제가 있음)

2011년 => Goolge의 Developer 블로그에서 HttpUrlConnetction 사용 권장

이후... => Volley나 Suare의 Okhttp가 등장하여 쉽게 Http 통신을 사용할 수 있게 됨.

2014년 => 롤리팝 이후 HttpClient 가 Deprecated되며 이를 베이스로 하는 Volley
도 Deprecated됨

이후.... => Okhttp와 그 래퍼인 Retrofit이 인기를 가짐.
Retrofit은 클라이언트 부분과 콜백 형식등을 플러그로 변경할수 있다는점에서 인기를 가짐.

1.  안드로이드 프로젝트 구성요소에 대해서 설명하시오.
    libs : 프로젝트에서 사용하는 다양한 라이브러리 소스가 저장되는 공간입니다.

androidTest : 앱의 일부 코드를 테스트하기 위한 소스를 저장하는 공간입니다.

java : 자바 코드를 저장하는 공간입니다. 표준 자바와 동일하게 패키지를 이용한 하위 디렉토리 생성 방식을 사용합니다.

res : 리소스(이미지, xml 레이아웃, 메뉴, 값)를 저장하는 공간입니다.

AndroidManifest.xml : 앱에 대한 전체적인 정보를 담고있는 파일입니다. 앱의 구성요소와 실행 권한 정보가 정의되어있습니다.

project > build.gradle : 프로그래머가 직접 작성한 그래들 빌드 스크립트 파일입니다.

gradle > build.gradle : 앱에 대한 컴파일 버전정보, 의존성 프로젝트에 대한 정의가 되어있는 파일입니다.

29. 디스플레이(display), 윈도우(window), 서피스(surface), 뷰(view), 뷰 그룹(view group), 뷰 컨테이너(view container), 레이아웃(layout)에 대해서 설명하시오.
    디스플레이 : 안드로이드 단말기가 가지고 있는 하드웨어 화면을 의미합니다.

윈도우 : 안드로이드에서 실행되는 앱이 그림(뷰)을 그릴 수 있는 영역을 의미합니다. 사용자로부터 입력(터치, 키) 이벤트를 받아 앱에 전달합니다.

서피스 : 윈도우에 그림(뷰)을 그릴 때 그림이 저장되는 메모리 버퍼를 의미합니다.

뷰 : 사용자 인터페이스를 구성하는 최상위 클래스를 말합니다. 윈도우의 서피스를 이용하여 화면에 어떤 모양으로 그림을 그릴지와 발생하는 이벤트를 어떻게 처리할 것인지에 대한 기능을 구현하고 있습니다. 뷰 중에서 일반적인 제어 역할을 하고 있는 것들을 위젯이라고 합니다.

뷰 그룹 : 여러개의 뷰를 포함하고 있는 뷰를 의미합니다.

뷰 컨테이너 : 다른 뷰를 포함할 수 있는 뷰를 의미합니다. 대표적으로 리스트 뷰(list view), 스크롤 뷰(scroll view), 그리드 뷰(grid view) 등이 있습니다.

레이아웃 : 뷰 그룹 중에서 내부에 뷰를 포함하고 있으면서 해당 뷰를 어떻게 윈도우에 배치할지 정의하는 관리자 역할을 하는 클래스 말합니다.

30. 인플레이션(inflation)이란 무엇인가?
    xml 레이아웃 파일로 정의한 정보를 런타임에 setContentView 메소드가 호출됨에 따라 메모리 상에 객체로 만들어주는 과정을 말합니다. 이 과정에서 xml 레이아웃 파일에서 뷰에 id를 설정하고 해당 id가 R.java 파일에 주소 값으로 환원되며 findViewById 메소드와 id를 이용하여 코드 상으로 뷰 객체를 가져와 제어할 수 있습니다.

31. 안드로이드에서 색상을 지정하는 다양한 방식은 어떤 것들이 있는가?
    #RGB, #ARGB, #RRGGBB, #AARRGGBB 총 4가지 방식이 있습니다. R은 붉은색, G는 초록색, B는 파란색의 정도를 나타내며 A는 알파 값 즉 투명도를 나타내는 수치입니다. 각각의 요소는 16진수(0부터 F까지)로 표현합니다.

32. 안드로이드의 크기를 표현하는 다양한 표현방법에 대해서 설명하시오.
    픽셀(px) : 화면의 픽셀을 의미합니다.

밀도 독립적 픽셀(dp, dip) : 160dpi(160인치에 들어가있는 픽셀 수) 화면을 기준으로 한 픽셀을 의미합니다.

축척 독립적 픽셀(sp, sip) : 가변 글꼴을 기준으로 한 픽셀을 의미합니다. 글꼴의 설정에 따라 차이가 있습니다.

텍스트 크기(em) : 글꼴과 상관없이 동일한 텍스트 크기를 표시하기 위한 단위입니다.

그 외 인치(in), 밀리미터(mm)가 있습니다.

1.  안드로이드의 테스크란?

Task는 어플리케이션에서 실행되는 Activity를 관리하는 스택입니다. 선입 후출의 형태로 나중에 적제된 액티비티가 가장 먼저 사용됩니다. 최초적재된 엑티비티는 Root Activity라고 하고 마지막에 적재된 Activity는 Top Activity라고 합니다.

Flag를 이용하여 엑티비티의 흐름을 제어 할 수 있습니다.

16. Realm이란? (SLite와의 비교) [렐름]

slite,realm은 안드로이드 단말에서 사용하는 관계형 데이터베이스입니다.

slite는 오픈소스 데이터베이스로 OS와 상호작용하기위해 SLiteOpenHelper인터페이스를 이용합니다. SLite는 C언어로 되어있고 경량데이터베이스이며 하나의 디스크 파일에 모든 데이터를 저장 할 수 있습니다.

Realm은 크로스 플랫폼 기반의 모바일 데이터베이스입니다. IOS와 Android에서 모두 사용이 가능하며 성능 및 효율성이 우수합니다. 설치도 간편하며 쿼리 응답속도도 기타 ORMLite나 SLite보다 더 좋습니다. 크로스 플랫폼이기 때문에 협업에서 유용합니다.

특징으로는 zero-copy모델을 사용하기 때문에 데이터 객체 자체에서 그대로 작업이 가능합니다.
크로스 플랫폼이기 때문에 특정 OS를 가리지 않고 동기화 될 수 있습니다.
ACID를 준수합니다.

Realm은 데이터베이스 컨테이너의 인스턴스입니다.
SLite 기반의 ORM 프레임워크 입니다.

87. Manifest : 애플리케이션에 대한 필수적인 정보를 안드로이드 플랫폼에 알려준다. 모든 안드로이드 1. 앱은 반드시 AndroidManifest.xml 파일을 자신의 루트 디렉토리에 가지고 있어야한다. 공식문서
88. gradle : 고급 빌드 툴킷인 Gradle을 사용하여 빌드 프로세스를 자동화하고 관리하는 한편, 1. 여러분은 유용한 사용자 지정 빌드 구성을 정의할 수 있습니다. 공식문서
89. src : JUnit 테스트 코드를 비롯한 Java, kotlin 소스 코드 파일을 포함합니다. 이들 파일은 1. 패키지 이름별로 구분
90. res : 코드가 아닌 모든 리소스(예: XML 레이아웃, UI 문자열, 비트맵 이미지 등)를 포함합니다. 1. 이들 리소스는 해당 하위 디렉토리로 나뉩니다.

## 액티비티

66. 액티비티 백 스택 설명
1. 2. 액티비티(activity)가 무엇인지와 액티비티 생명주기에 대해서 설명하시오.
      안도르이드에서 화면을 관리하며 사용자가 발생시키는 다양한 이벤트를 처리하는 컴포넌트입니다.

부모 액티비티에서 새로운 자식 액티비티를 실행하고자 한다면 먼저 매니페스트 파일에 해당 자식 액티비티를 추가 해줘야합니다. 다음으로 부모 액티비티에서 startActivity 메소드에 인텐트를 파라미터로 넘겨 실행하거나 startActivities 메소드를 이용하여 여러개의 액티비티를 한꺼번에 실행할 수 있습니다.

액티비티의 실행과정은 첫 번째로 부모 액티비티에서 자식 액티비티를 생성 및 호출합니다. 두 번째로 액티비티 매니저 서비스가 해당 앱 프로세스에서 인텐트를 복사해온 후 매니페스트 파일에서 해당 인텐트에 명시되어있는 액티비티를 찾고 어떻게 실행시켜야할지 결정합니다. 세 번째로 찾아낸 액티비티를 실행하고 다시 해당 앱 프로세스에 인텐트를 복사하여 넘겨줍니다. 그 외 자식 액티비티 내의 onCreate 메소드에서 setContentView 메소드에 레이아웃의 아이디를 파라미터로 넘겨 해당 액티비티의 화면을 구성하게됩니다.

액티비티는 크게 3가지 상태가 존재합니다. 먼저 실행(running) 상태는 액티비티 스택의 최상위에 있으며 포커스를 가지고 있어 사용자에게 보이는 상태입니다. 다음으로 일시 중지(paused) 상태는 사용자에게 보이기는 하지만 다른 액티비티가 위에 있어 포커스를 받지 못하는 상태를 말합니다. 예를들어 대화상자가 위에 있어 일부가 가려져 있는 경우를 말합니다. 마지막으로 중지 (stopped) 상태는 다른 액티비티에 의해 완전히 가려져 보이지 않는 상태를 말합니다.

액티비티가 처음 만들어지면 onCreate 메소드가 호출되어 레이아웃을 구성합니다. 이후 onStart 메소드가 화면에 보이기 직전에 호출됩니다. 다음으로 onResume 메소드가 사용자 상호작용(화면이 포커스를 얻었을 때)하기 바로 전에 호출됩니다. 이 3가지 메소드가 호출되어 액티비티는 실행 상태를 갖게됩니다. 이후 포커스를 잃었을 때 onPause 메소드가 호출되고 일시 중지 상태가 됩니다. 일시 중지 상태에서 다시 포커스를 획득하면 onResume 메소드가 호출되거나 다른 액티비티에 의해서 완전히 화면이 가려졌는지 여부를 확인하여 가려져 보이지 않는 경우 onStop 메소드가 호출되어 중지 상태가됩니다. 정지 상태에서 다시 화면이 보이기 직전에 onRestart 메소드가 호출되고 onStart 메소드가 차례로 호출됩니다. 그 외 finish 메소드가 실행되어 해당 액티비티가 종료되기 직전에 onDestroy 메소드가 실행됩니다.

가끔은 일시 중지나 중지 상태에서 시스템이 메모리가 부족하다고 판단될 경우 onCreate 메소드부터 다시 해당 액티비티를 구동합니다. 이 경우 onStop, onResume 메소드 호출이 생략됩니다. 따라서 onSaveInstanceState, onRestoreInstanceState 메소드를 이용하여 액티비티가 갑자기 죽을 것을 대비해서 상태를 저장하고 복원하기 위한 작업을 정의해줄 수 있습니다.

36. 액티비티간 데이터 전달에서 임의의 클래스 객체를 바로 전달하지 못하는 이유는 무엇이고 전달하기 위해서는 어떤 처리가 필요한가?
    액티비티간 전달할 수 있는 데이터의 type은 보통 기본형으로 정해져있습니다. 그 이유는 인텐트를 이용하여 액티비티의 데이터를 전달하는 과정에서 현재 실행중인 앱 프로세스가 시스템 프로세스로 실행중인 액티비티 매니저 서비스 프로세스에게 인텐트를 전달합니다. 이 경우 프로세스간 통신이기 때문에 인텐트에 있는 값들을 복사하여 넘기는 방식으로 처리되기 때문에 객체 주소를 바로 넘기지 못하는 문제가 발생합니다. 따라서 이 문제를 해결하기 위해 자신이 임의로 만든 클래스 객체를 전달하기 위해서는 Serilizable이나 Parcelable 인터페이스를 상속받아 객체를 직렬화하여 넘기는 방식을 사용해야합니다.

37. 부모 액티비티에서 자식 액티비티의 결과 값을 받아오기 위해 어떻게 해야하는가?
    먼저 부모 액티비티에서 startActivityForResult 메소드를 이용하여 인텐트와 리퀘스트 코드를 파라미터로 넘깁니다. 이후 자식 액티비티에서 setResult 메소드에 결과 코드와 데이터를 파라미터로 넘깁니다. 다시 부모 액티비티에서 onActivityResult 메소드를 오버라이딩하여 자식 액티비티에서 보낸 결과 코드와 데이터를 받아 처리하는 코드를 작성할 수 있습니다. 이후 실행과정에서 자식 액티비티의 finish 메소드가 호출되면 부모 액티비티가 다시 화면에 나타나면서 onResume 메소드가 실행됩니다. 이때 onActivityResult 메소드가 작동하게 됩니다.

38. 액티비티 launchMode에는 어떤 값들이 있는가?

    Manifest를 통한 launchMode는 4가지 모드를 지원한다. ()안의 내용은 intentflag로 이용할 때의 형태이다.

    standard (FLAG_ACTIVITY_STANDARD)

    activity를 여러번 생성할 수 있다. 또한 activity의 instance는 어떤 task이던지 존재 할 수 있다.

    singleTop(FALG_ACTIVITY_SINGLE_TOP)

    target task에 동일한 activity가 top에 위치해 있을 때만 instance를 새로 생성하지 않고, top에 있던 instance의 onNewIntent()를 대신 호출해 준다.

    singleTask(FALG_ACTIVITY_SINGLE_TASK)

    시스템이 새 태스크 루트에 액티비티를 생성하고, 인텐트를 해당 액티비티로 라우팅 한다. 그러나 액티비티 인스턴스가 이미 존재하는 경우, 시스템은 새 인스턴스를 생성하는 대신 onNewIntent() 메서드를 호출하여 인텐트를 기존의 인스턴스로 라우팅한다.

    singleInstance(FLAG_ACTIVITY_SINGLE_INSTANCE)

    시스템이 태스크내에 인스턴스를 보유하고 있는 상황에서 새 액티비티 인스턴스를 만들지 않는 점이 singTask와 비슷하나, 액티비티는 항상 해당 태스크의 단일 멤버이다.

39. Activity?

    액티비티는 일종의 어플리케이션 구성요소 로서, 사용자와 상호작용 할 수 있는 화면을 제공한다. 액티비티 마다 layout.xml 파일을 구현 함으로써 사용자에게 인터페이스를 제공 해 줄 수 있다.

    액티비티를 사용하기 위해서는 아래와 같은 내용들을 알아야 한다.

    setContentView()를 이용하여 액티비티의 View를 Draw

    AndroidManifest 파일에 Activity를 등록

    라이프 사이클 콜백 처리

    onCreate, onStart, onResume, onPause, onDestroy

    액티비티 시작시에 정보를 전달하거나 액티비티가 종료될 때 결과를 리턴할 수 있다.

    액티비티의 3가지 상태?

    활성화 (Active) 또는 실행 중 (Running) 상태

    Activity가 전면에 나와서 실행되고 있을 때

    현재 Task에 대한 Activity Stack의 최상위에 존재하고 있을 때

    이 상태의 Activity는 사용자와 상호작용 할 수 있다.

    멈춤(pauese) 상태

    사용자의 포커스를 가지고 있지 않지만 여전히 화면지 보여지고 있을 때

    다른 액티비티가 위에 위치 하지만 그 액티비티가 투명상태 혹은 전체화면을 채우지 못해 아직은 이전 액티비티가 보이는 상태 이 때 이전 액티비티의 상태는 멈춤 상태이다.

    극도로 메모리가 부족한 상태에서는 시스템에 의해 강제로 종료될 수 있다.

    정지(Stopped) 상태

    다른 Activity에 의해서 완전히 가려져, 더 이상 사용자에게 보여지지 않을 때

40. 액티비티 생명 주기

    onCreate()

    액티비티가 최초 생성될 때 한번만 호출

    액티비티의 대부분 초기설정을 이곳에서 수행

    액티비티가 재성생되는 경우 이전상태값을 저장한 번들 객체가 전달

    Bundle savedInstanceState
    onStart()

    액티비티가 사용자에게 보이기 직전 호출

    onResume()

    액티비티가 사용자와 상호작용을 하기 직전 호출

    onPause

    다른 액티비티의 호출로 해당 액티비티가 백그라운드로 진입할때 호출

    CPU를 소모하는 작업들을 중단 시킬 때 이곳에서 수행하면 적절

    이 메소드가 리턴 되기전까지는 다음 액티비티의 실행이 이루어지지 않음 > 되도록 빨리 끝내야함

    onStop

    액티비티가 더 이상 화면에 나오지 않음

    onDestroy

    액티비티가 소멸되기 전에 호출

    개발자가 finish()메소드를 호출 했을 때 혹은 시스템이 메모리를 확보하기 위해 액티비티를 일시적으로 종료 할 때 호출.

    위의 두가지 시나리오는 isFinishing()메소드를 통해 구분가능

    onRestart

    액티비티가 중단 되었다가 다시

    시작되기 직전에 호출

    이 뒤에는 항상 onStart()가 호출

    액티비티 재시작 경우

    onPause() 상태까지 호출 뒤 재시작 된 경우

    onPause() > onResume()

    onStop() 상태까지 호출 뒤 재시작 된 경우

    onStop() > onRestart() > onStart() > onResume()

41. Activity의 생명 주기에 대해서 설명해주세요.

42. 만약 앱을 사용하는 도중에 카카오톡 메시지가 온다면 사용하던 앱의 TopActivity의 생명주기는 어떤 상태가 되나요?

    - onPause 상태가 됩니다.

43. onRestart는 언제 호출이 되나요?

    - Activity가 중지 상태에서 다시 화면에 표시되기 직전에 호출됩니다. onRestart->onStart->onResume-> ActivityRunning..

44. 안드로이드의 액티비티와 액티비티의 수명주기에 대해서 설명해보세요.

안도르이드에서 화면을 관리하며 사용자가 발생시키는 다양한 이벤트를 처리하는 컴포넌트입니다
부모 액티비티에서 새로운 자식 액티비티를 실행하고자 한다면 먼저 매니페스트 파일에 해당 자식 액티비티를 추가 해줘야합니다. 다음으로 부모 액티비티에서 startActivity 메소드에 인텐트를 파라미터로 넘겨 실행하거나 startActivities 메소드를 이용하여 여러개의 액티비티를 한꺼번에 실행할 수 있습니다.
액티비티의 실행과정은 첫 번째로 부모 액티비티에서 자식 액티비티를 생성 및 호출합니다. 두 번째로 액티비티 매니저 서비스가 해당 앱 프로세스에서 인텐트를 복사해온 후 매니페스트 파일에서 해당 인텐트에 명시되어있는 액티비티를 찾고 어떻게 실행시켜야할지 결정합니다. 세 번째로 찾아낸 액티비티를 실행하고 다시 해당 앱 프로세스에 인텐트를 복사하여 넘겨줍니다. 그 외 자식 액티비티 내의 onCreate 메소드에서 setContentView 메소드에 레이아웃의 아이디를 파라미터로 넘겨 해당 액티비티의 화면을 구성하게됩니다.
액티비티는 크게 3가지 상태가 존재합니다. 먼저 실행(running) 상태는 액티비티 스택의 최상위에 있으며 포커스를 가지고 있어 사용자에게 보이는 상태입니다. 다음으로 일시 중지(paused) 상태는 사용자에게 보이기는 하지만 다른 액티비티가 위에 있어 포커스를 받지 못하는 상태를 말합니다. 예를들어 대화상자가 위에 있어 일부가 가려져 있는 경우를 말합니다. 마지막으로 중지 (stopped) 상태는 다른 액티비티에 의해 완전히 가려져 보이지 않는 상태를 말합니다.
액티비티가 처음 만들어지면 onCreate 메소드가 호출되어 레이아웃을 구성합니다. 이후 onStart 메소드가 화면에 보이기 직전에 호출됩니다. 다음으로 onResume 메소드가 사용자 상호작용(화면이 포커스를 얻었을 때)하기 바로 전에 호출됩니다. 이 3가지 메소드가 호출되어 액티비티는 실행 상태를 갖게됩니다. 이후 포커스를 잃었을 때 onPause 메소드가 호출되고 일시 중지 상태가 됩니다. 일시 중지 상태에서 다시 포커스를 획득하면 onResume 메소드가 호출되거나 다른 액티비티에 의해서 완전히 화면이 가려졌는지 여부를 확인하여 가려져 보이지 않는 경우 onStop 메소드가 호출되어 중지 상태가됩니다. 정지 상태에서 다시 화면이 보이기 직전에 onRestart 메소드가 호출되고 onStart 메소드가 차례로 호출됩니다. 그 외 finish 메소드가 실행되어 해당 액티비티가 종료되기 직전에 onDestroy 메소드가 실행됩니다.
가끔은 일시 중지나 중지 상태에서 시스템이 메모리가 부족하다고 판단될 경우 onCreate 메소드부터 다시 해당 액티비티를 구동합니다. 이 경우 onStop, onResume 메소드 호출이 생략됩니다. 따라서 onSaveInstanceState, onRestoreInstanceState 메소드를 이용하여 액티비티가 갑자기 죽을 것을 대비해서 상태를 저장하고 복원하기 위한 작업을 정의해줄 수 있습니다.

49. 태스크(task)란 무엇인가?
    예를들어 어떤 앱에서 앨범 앱을 실행하는 기능이 있다면 이 앱은 두개의 앱을 실행하는 형태가 되지만 사용자 입장에서는 하나의 앱에서 화면이 전환된다고 판단합니다. 이와 같은 사용자 입장에서 논리적인 화면 구성의 단위를 태스크라고 말합니다.

50. 액티비티의 4가지 launchMode에 대해서 비교 설명하시오.

### 프레그먼트

14. 프레그먼트

    액티비티 내에 배치되어 어플리케이션 사용자 인터페이스를 구성하는 안드로이드 구성요소이다.

    프래그먼트의 특징

    액티비티를 분할하여 화면의 한부분을 정의한다.

    액티비티와 같이 레이아웃, 동작 처리, 생명주기를 가지는 독립적인 모듈이다.

    다른 액티비티에서도 사용 할 수 있어 재사용성이 뛰어나다.

    액티비티 내에서 실행 중에 추가, 제거가 가능하다.

15. Fragment를 생성 할 때 default 생성자만 사용하길 추천하는 이유?

프로그먼트를 만들 때는 생성자를 오버로딩 하지 않고 생성 시 파라미터를 Bundle에 담아 setArgument() 함수를 호출하는 방식을 사용하는 것이 일반적이다. 왜냐하면 안드로이드에 의해서 프래그먼트가 복원될 때는 프래그먼트의 기본 생성자를 호출하기 때문에 오버로딩된 생성자의 호출이 보장되지 않는다.

16. 프래그먼트사이의 커뮤니케이션은 어떤 방식으로 하는가?

서로 다른 fragment들 끼리는 직접적으로 정보를 주고 받을 수 없다. Fragment끼리의 통신은 반드시 host activity(프래그먼트들이 바인딩되어 있는 activity)를 거쳐서 이루어져야 한다. 프래그먼트에 콜백함수를 정의하고 액티비티에 해당 콜백함수를 구현 함으로써 프래그먼트 사이 통신이 가능하다.

17. 프래그먼트 생명주기

1. 프래그먼트의 생명주기에 대해서 설명하세요.

onAttach함수가 OnCreate이전에 호출됩니다. 그 이후 OnCreate함수가 호출되고 OncreateView에서 LayoutInflater로 UI관련 잡업을 할 수 있습니다. 그리고 화면이 포커스를 잃었을때는 onPause OnStop onDestroyView가 호출되고
종료시에 onDestory onDetach()가 호출됩니다.

2. 프레그먼트(fragment)가 와 프레그먼트 생명주기에 설명하시오.
   프레그먼트는 액티비티의 일부분에만 배치되는 화면 및 동작을 조작하기 위한 객체입니다. 안드로이드 3.0(허니콤)에서 화면이 비교적 큰 태블릿의 등장으로 작은 단위의 화면의 생명주기 관리할 필요가 있어 추가되었습니다. 프레그먼트 매니저를 통해서 여러개의 프레그먼트를 조작할 수 있습니다. 레이아웃 xml 파일에서 다른 뷰들과 함께 배치될 수 있습니다.

   액티비티가 생성되면 프레그먼트 매니저는 초기화(initializing) 상태가 됩니다. 프레그먼트가 매니저에 의해 추가되면 onAttach, onAttachFragment, onCreate 메소드가 차례로 실행됩니다. 다음으로 액티비티의 onCreate 메소드 호출 이후 매니저는 생성(created) 상태로 변경됩니다. 이때 onCreateView, onViewCreated, onActivityCreated 메소드가 차례로 호출됩니다. 다음으로 액티비티의 onStart 메소드가 호출되면 매니저는 시작(started) 상태로 onStart 메소드를 호출합니다. 이후 액티비티의 onResume 메소드가 호출되면 매니저 역시 재시작(resume) 상태로 변하며 onResume 메소드를 호출합니다. 그 외 액티비티가 화면에서 보이지 않을경우 호출되는 onStop 메소드 호출 이후 매니저는 중지(stop) 상태가 되며 액티비티의 onDestroy 메소드 호출 이후 매니저는 onDestroyView 메소드를 호출합니다.

## 서비스

52. 백그라운드에서 UI 업데이트 하는 방법
53. startService와 bindService의 차이

54. 서비스(service)가 무엇인지와 서비스 생명주기에 대해서 설명하시오.
    서비스는 백그라운드에서 실행되는 구성 요소입니다. 서비스는 사용자에게 보이는 화면이 존재하지 않으며, 정해지지 않은 시간 동안 운영됩니다. 각각의 서비스는 매니페스트 파일에 서비스 태그를 이용하여 선언해야합니다. 서비스는 Service 클래스를 상속받아 onStartCommand 또는 onBind 메소드를 재정의하여 구현할 수 있습니다.

    서비스는 다른 구성 요소들처럼 메인 쓰레드에서 동작합니다. 따라서 CPU를 많이 사용하거나 대기 상태를 필요로 하는 경우 새로운 쓰레드를 이용하여 생성해야합니다. 또한 서비스의 객체는 단말에서 오직 1개만 생성되어 관리합니다.

    먼저 서비스가 startService 메소드로 실행되는 경우 서비스가 생성될 때 onCreate 메소드가 실행됩니다. 이후 서비스가 실행을 시작할 때 onStartCommand 메소드가 호출되며 서비스의 상태가 실행중으로 변경됩니다. 이후 stopService 메소드가 실행되면 서비스가 종료되며 onDestroy 메소드를 호출하며 서비스의 상태가 종료로 변경됩니다.

    다음으로 서비스가 bindService 메소드로 실행되는 경우 서비스가 생성될 때 onBind 메소드가 호출됩니다. 다음으로 unbindService 메소드가 호출되어 바인딩이 해제되면 onUnbind 메소드가 호출됩니다. 이후 완전히 종료될 때 onDestroy 메소드가 호출됩니다.

## 브로드캐스트 리시버

24. 브로드캐스트 리시버

안드로이드 4대 컴포넌트 중 하나로 시스템이나 앱 등에서 이벤트 발생시 사용자에게 방송을 해주는 개념이다. 이렇게 방송된 이벤트는 각 앱에서 필요한 방송 이벤트를 받아들이고 이벤트에 대한 처리를 리시버를 통해 할 수 있게 해준다.

Local Broadcast와 LocalBroadcastManager?

Global Broadcast

일반적으로 이야기하는 BroadCast. 프로세스 경계를 무시하고 안드로이드 시스템 상 등록된 모든 Receiver 들에게 전달되는 Broadcast이다.

Local Broadcast

현재 프로레스 안에서만 유효한 Broadcast이다. GlobalBroadcast에 비해 훨씬 시스템 부하가 적다. 액티비티 내부의 객체간에 상호 의존성을 낮추어 깔끔한 프로그램 구조를 만들 수 있다. Local Broadcast를 등록하는 방법은 LocalBroadcastManager의 객체를 getInstance()를 통해 얻어와 해당 매니져에 등록해야 한다.

LocalBroadcastManager.getInstance( getContext() ).registerReceiver( myReceiver, myFilter );
Broadcast를 보내는 방법도 LocalBroadcastManager를 이용한다.

LocalBroadcastManager.getInstance( getContext() ).sendBroadcast( new Intent( myAction ));

## 콘텐트 프로바이더

## 뷰, 커스텀 뷰

18. 안드로이드에서 View란 무엇인가?

View는 액티비티에서 화면을 구성하는 최소 단위로 화면에 보이는 모든것은 View이다. 또 다른말로 위젯이라고도 하며 대표적으로 ImageView, TextView, EditText, Button 등이 View를 상속 받아 만든 클래스이다.

19. View.GONE과 View.INVISIBLE의 차이

GONE

보이지도 않고 영역도 차지하지 않는다. (아예 사라짐)

INVISIBLE

보이지는 않지만 영역은 차지하고 있다.

20. View와 ViewGroup의 차이점?

ViewGroup은 n개의 View를 담을 수 있는 컨테이너로 ViewGroup 또한 View를 상속받아 만든 클래스 입니다. 또 다른 말로 레이아웃이라고도 하며 대표적으로 LinearLayout, RelativeLayout, FrameLayout, ConstraintLayout 등이 있다.

그래서 ViewGroup안에 View 뿐만아니라 ViewGroup을 담을 수 있다.

21. SurfaceView란?

SurfaceView는 View를 상속받는 클래스이다. 일반 View는 onDraw메소드를 시스템에서 자동으로 호출해줌으로써 화면을 그린다. SurfaceView는 그리기를 시스템에 맡기는 것이 아니라 스레드를 이용해 강제로 화면에 그림으로써 원하는 시점에 바로 화면에 그릴 수 있다. 애니메이션이나 동영상과 같이 연산처리가 많이 필요한 뷰를 위해 사용된다.

SurfaceView에는 다음 장 화면을 미리 그려두고, 그리기가 끝나면 바로 전환하는 더블버퍼링이라는 기능이 있어 처리 속도를 빠르게 할 수 있다.

22. RelativeLayout과 LinearLayout, Constraint Layout

LinearLayout

뷰가 가로 또는 세로로 순차적으로 나열되는 레이아웃이다.

android:orientation속성으로 Horizontal 또는 Vertical 설정 가능하다.

기본값은 Horizontal이다.

RelativeLayout

따로 위치를 지정하지 않으면 뷰가 0,0위치에 계속 쌓이는 레이아웃이다.

최상위 부모 레이아웃 상대위치 또는 다른 view의 id 를 참조해 특정 뷰에 대해 상대적인 위치를 지정할 수 있다.

Constraint Layout

복잡한 레이아웃을 단순한 계층구조를 이용하여 표현할 수 있는 ViewGroup

형제 View들과의 관계를 정의해서 레이아웃을 구성하여, RelativeLayout과 비슷하지만 더 유연하고 강력한 기능들을 제공한다.

RelativeLayout에서 불가능했던 자식 뷰간의 상호관계 정의가능

LinearLayout을 써야만 했던 뷰 비율 조정도 간단하게 가능

뷰 계층을 간단하게 구성하여 유지보수, 성능 향상

1. 리스트뷰에서 사용되는 뷰홀더(ViewHolder Pattern) 패턴에 대해서 아시는 만큼 설명해주세요.

   - 리스트뷰에서 리스트의 개수가 많은 상황에서 findViewById를 통한 XML 리소스 접근이 빈번할 경우 성능저하가 발생하기 때문에 View 객체를 ViewHolder에 홀드시켜 성능을 개선하기 위한 패턴입니다.

2. 커스텀뷰를 만들어 봤는지 설명해주세요.

3. WebView란?

안드로이드 프레임워크에 내장된 컴포넌트로 View의 형태로 임베딩 할 수 있는 형태이다.

웹페이지를 보거나 안드로이드 앱 안에서 HTML을 호출하여 앱을 구현하는 하이브리드 형태의 앱을 개발하는데에도 많이 사용된다.

## 기타

7. 코틀린의 장점에 대해 설명하시오

기존의 자바 코드의 보일러 플레이트 구문을 최소화 시킬 수 있습니다.

기존의 자바에서도 람다표현식을 이용하여 코드의 간소화를 위해 노력했습니다.
java8에서는 Retrolambda라이브러리를 사용하지 않고 람다표현식이 가능합니다.
그렇지만 안드로이드 스튜디오 2.4버전 이상부터 JDK 1.8로 빌드가 가능하고 minsdk도 24부터이기때문에
실질적으로 사용하지 못합니다. 즉 JDK 1.6기반의 API와 문법적으로 조금 추가된 형태로 빌드 할 수 있다고 봅니다.

안드로이드의 대표적인 보일러 플레이트 구문은 레이아웃에 정의한 뷰 레퍼런스를 가지고 오는 부분이나 SLite트랜젝션을 처리하는 부분 등이 있습니다.

또 자바 8의 스트림 API를 사용할 수도 없습니다.

스트림에 대한 대비로는 streamsupport, Lightweight-Strem-API가 있습니다.

RxJAVA또한 자바 8 스트림의 훌륭한 대안이고 안드로이드 커뮤니티에서 많이 쓰이고 있습니다.

하지만 위의 라이브러리들의 의존성문제와 기존 라이브러리에 대한 학습등이 부담으로 다가온다는 사실이 있습니다.

코틀린의 좋은점으로는 NullPointerException다루기, 보일러 플레이트 개선하기, Collections에 filter,map,foreach같은 고차함수를 적용할 수 있고, 변경가능한 컬렉션과 불가능한 컬렉션을 엄격히 구분합니다. 서버에서 수신받은 데이터를 컬렉션으로 다룰 일이 많기때문에 코드를 보다 간결하고, 안전하게 만드는 데 도움이 됩니다. 또 확장함수(이미 존재하는 클래스에 새로운 함수를 추가)라는 강력한 기능도 있습니다.

또 자바와 호완성이 무척 좋고 기존의 라이브러리를 제약없이 사용 할 수 있습니다.

하지만 새로운 언어를 배워야 한다는 점에대한 부담감과 기술적 이슈가 발생했을때 대응기간이 상대적으로 길어 질 수 있다는 단점도 분명 존재합니다.

## 안드로이드 패턴

1. 안드로이드 MVC 모델은 어떻게 구성되어있는가
   안드로이드에서 뷰는 화면에 실제로 보이는 구성을 만드는 영역으로 View 클래스를 상속하는 클래스를 이용하여 구성할 수 있습니다. 다음으로 컨트롤러는 뷰와 모델을 서로 연결하며 제어하는 영역으로 액티비티, 서비스, 브로드캐스트 리시버, 프래그먼트로 구성됩니다. 마지막으로 모델은 앱의 다양한 데이터를 저장하는 역할로 SLite를 이용한 DB, SharedPreference를 이용한 파일 시스템, 콘텐트 프로바이더가 있습니다.

2. 어플리케이션(application)과 컨텍스트(context)에 대해서 설명하시오.
   어플리케이션 앱 프로세스가 실행되면 가장 먼저 생성되는 객체로 하나의 어플리케이션 객체는 하나의 앱 프로세스와 대응됩니다. 앱이 백그라운드로 내려가도 앱 프로세스는 계속 살아있기 때문에 어플리케이션 객체도 살아있다고 할 수 있습니다.

컨텍스트는 안드로이드의 컴포넌트들이 동작하기 위해 필요한 정보를 담고 있는 객체를 말합니다. 각각의 컴포넌트들(액티비티, 서비스, 브로드캐스트 리시버 등)은 자신만의 컨텍스트를 가지고 있습니다. 컨텍스트 내에는 어플리케이션의 정보(패키지명 등), 컨텍스트가 실행되는데 필요한 정보(테마 등)를 얻거나 시스템 서비스(윈도우 매니저, 레이아웃 인플레이터 등)를 구동하는데 사용됩니다.

44. 노티피케이션(notification)은 무엇인가?
45. 안드로이드에서 로그(log)를 출력하는 방법과 종류를 설명하시오.
46. 스타일(style), 테마(theme)에 대해서 설명하시오.

47. 뷰 홀더 패턴(view holder pattern)에 대해서 설명하시오.
48. 나인패치(9patch)란 무엇인가?

49. 안드로이드의 메모리 관리 방식에 대해서 설명하시오.
    안드로이드는 액티비티, 서비스, 리시버, 프로바이더를 실행하기 위해 앱이 실행되는 과정에서 프로세스를 생성합니다. 실행중인 모든 앱은 컴포넌트가 모두 종료되어도 다음에 이 앱을 다시 실행할 가능성이 높기 때문에 프로세스를 바로 제거하지 않습니다. 바로 종료하지 않는 이유는 앱을 실행하기 위해 프로세스를 생성하는 과정에서 딜레이가 발생하는데 이 딜레이를 줄이기 위함입니다. 따라서 사용자에 의해 다시 앱이 실행되면 남아있던 프로세스가 존재하는 경우 바로 실행됩니다. 이 과정에서 쌓여있던 많은 프로세스로 인해 메모리가 부족해지는 경우 프로세스의 우선순위(사용빈도)에 따라 프로세스를 종료하여 메모리를 확보합니다.
50. ANR, LMK, OOM
51. Asynctask, coroutine, retrofit
52. parcel, serializable
53. Data binding
54. View binding
55. AIDL
56. 데이터 저장 방식 file, db, shared preference property, network
57. 서비스 액티비티 연동
58. startService, BindService
59. 콘텐트 프로바이더와 콘텐트 리조버 차이
60. 안드로이드 브로드캐스트 리시버 액티비티 간 연동
61. 도즈 모드 설명
62. xml, view가 그려지는 과정 (커스텀 뷰를 만드는 과정)
63. 스타일(res -> values -> styles.xml)을 사용해봤나? 언제 사용해야 하나?
64. MVVM ViewModel과 AAC ViewModel 차이점
65. Room과 SharedPreferences 비교

66. 리스트뷰와 리사이클러뷰 비교
67. 리사이클러뷰의 어댑터가 무엇인가? 무슨 역할을 하나?
68. 웹툰 및 전자책과 같은 앱을 구현하기위해 ViewPager를 사용한다 가정하고, 메모리와 관련해서 1. 어떤방식으로 구현할지 설명하시오.
    자료 구조와 관련한 질문(예: 좋아하는 언어로 연결리스트를 구현해보세요(화이트보드 또는 컴퓨터에 작성))
69. 일반 View와 Surface View의 차이
70. Activity간 데이터 전달에서 POJO(Plain Old Java Object)를 전달하지 못하는 이유와 해결방법 인텐트를 전달할때는 IPC를 이용한다. 그러나 프로세스간 통신시에는 메모리참조가 안된다. 그래서 파일에 쓰는 방식을 이용하는데 이 때 직렬화, 역직렬화를 통해 파일을 참조한다
71. 안드로이드 O의 변경사항
72. Dalvik과 Art의 차이점 참고
73. Dependency Injection이란?
