# 이진 탐색

완전 탐색하고는 다르게 정렬된 상태에서 값을 찾는 방법 입니다.
반을 나누어서 찾고 반을 나누어서 찾고를 반복합니다.

## 시간복잡도

전체 탐색 : O(N)
이분 탐색 : O(logN)

## 진행 순서

- 우선 정렬을 해야 함
- left와 right로 mid 값 설정
- mid와 내가 구하고자 하는 값과 비교
- 구할 값이 mid보다 높으면 : left = mid+1
  구할 값이 mid보다 낮으면 : right = mid - 1
- left > right가 될 때까지 계속 반복하기

```cpp
#include <vector>
#include <algorithm>

int main(){
  vector<int> arr = {2, 3, 1, 4};
  sort(arr.begin(), arr.right());


  int left = 0; // 시작
  int right = arr[arr.size()-1]; // 끝

  while(left <= right) {

    int sum = 0;
    int mid = (left+right)/2; // 시작과 끝의 중간값

    for (int i = 0; i < arr.length; i++) {
      if(arr[i] > mid)
        sum+=mid;
      else
        sum+=arr[i];
    }

    if(sum > M) right = mid - 1;
    else left = mid + 1;

  }

  return right;
}
```

## 파라메틱 서치

최적화 문제를 결정 문제로 바꾸는 것이다.

~~~~ 내용
