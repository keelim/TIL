# 필수로 알아야 하는 것들

- [필수로 알아야 하는 것들](#필수로-알아야-하는-것들)
  - [운영체제](#운영체제)
    - [프로세스와 스레드](#프로세스와-스레드)
      - [스레드 세이프 Thread safe](#스레드-세이프-thread-safe)
    - [교착상태와 경쟁상태](#교착상태와-경쟁상태)
    - [메모리 할당, 배치 교체](#메모리-할당-배치-교체)
    - [페이징과 세그먼트](#페이징과-세그먼트)
    - [뮤텍스, 세마포어가 뭔지, 차이점은](#뮤텍스-세마포어가-뭔지-차이점은)
  - [문맥교환](#문맥교환)
  - [가상메모리란](#가상메모리란)
    - [시스템 콜과 서브루틴](#시스템-콜과-서브루틴)
  - [데이터베이스](#데이터베이스)
    - [DBMS 및 기능](#dbms-및-기능)
    - [인덱스 관련 내용](#인덱스-관련-내용)
    - [데이터베이스 View 및 가상 테이블](#데이터베이스-view-및-가상-테이블)
    - [정규화](#정규화)
    - [이상현상이란](#이상현상이란)
    - [데이터베이스를 설계할 때 가장 중요한 것이 무엇이라고 생각하나요](#데이터베이스를-설계할-때-가장-중요한-것이-무엇이라고-생각하나요)
    - [Commit과 Rollbak](#commit과-rollbak)
    - [조인](#조인)
  - [네트워크와 웹](#네트워크와-웹)
    - [OSI 7계층](#osi-7계층)
    - [TCP/IP 프로토콜을 스택 4계층으로 짓고 설명하시오](#tcpip-프로토콜을-스택-4계층으로-짓고-설명하시오)
    - [서버와 클라이언트](#서버와-클라이언트)
    - [TCP란](#tcp란)
    - [3-way handshaking](#3-way-handshaking)
    - [TCP 4way 핸드쉐이킹(연결해제요청)](#tcp-4way-핸드쉐이킹연결해제요청)
    - [TCP의 연결 설정 과정(3단계)과 연결 종료 과정(4단계)이 단계가 차이나는 이유](#tcp의-연결-설정-과정3단계과-연결-종료-과정4단계이-단계가-차이나는-이유)
    - [UDP란](#udp란)
    - [TCP/UDP 차이](#tcpudp-차이)
    - [HTTP와 HTTPS의 차이는](#http와-https의-차이는)
    - [GET과 POST ()](#get과-post-)
    - [GET()](#get)
    - [POST()](#post)
    - [조회하기 위한 용도 POST가 아닌 GET 방식을 사용하는 이유](#조회하기-위한-용도-post가-아닌-get-방식을-사용하는-이유)
    - [네트워크 장비](#네트워크-장비)
    - [쿠키 세션](#쿠키-세션)
    - [쿠키](#쿠키)
    - [세션](#세션)
    - [REST와 RESTful의 개념](#rest와-restful의-개념)
      - [REST 구성 요소](#rest-구성-요소)
    - [REST 특징](#rest-특징)
    - [REST API](#rest-api)
    - [REST API의 특징](#rest-api의-특징)
    - [RESTful](#restful)
      - [RESTful의 목적](#restful의-목적)
    - [RESTful 하게 API 를 디자인 한다는 것은 무엇을 의미하는가.(요약)](#restful-하게-api-를-디자인-한다는-것은-무엇을-의미하는가요약)
    - [WebSocket](#websocket)
    - [일반 TCP Socket과의 차이점](#일반-tcp-socket과의-차이점)
    - [Socket.io](#socketio)
    - [대용량 트래픽 처리 관련 이슈](#대용량-트래픽-처리-관련-이슈)
  - [자료구조와 알고리즘](#자료구조와-알고리즘)
    - [일치하는 자료구조 작성하기](#일치하는-자료구조-작성하기)
    - [BFS 를 쓰는 방법](#bfs-를-쓰는-방법)
    - [이진탐색](#이진탐색)
    - [정렬 알고리즘 정리](#정렬-알고리즘-정리)
    - [해시란](#해시란)
      - [HashMap, TreeMap, LinkedHashMap](#hashmap-treemap-linkedhashmap)
    - [트리](#트리)
    - [Max Heap, Min Heap, 우선순위 큐](#max-heap-min-heap-우선순위-큐)
    - [최단 경로 알고리즘 다익스트라(우선 순위 큐), 플로이드 와샬(다이나믹)](#최단-경로-알고리즘-다익스트라우선-순위-큐-플로이드-와샬다이나믹)
    - [MST 알고리즘 크루스칼(유니온, 파인드), 프림 알고리즘(우선 순위 큐)](#mst-알고리즘-크루스칼유니온-파인드-프림-알고리즘우선-순위-큐)
    - [Stack, Queue](#stack-queue)
  - [언어, 코드 및 기타](#언어-코드-및-기타)
  - [객체 지향 프로그래밍](#객체-지향-프로그래밍)
    - [프레임워크](#프레임워크)
    - [프레임워크 사용의 장/단점](#프레임워크-사용의-장단점)
    - [라이브러리](#라이브러리)
    - [라이브러리와 API의 차이점](#라이브러리와-api의-차이점)
    - [프레임워크와 라이브러리의 차이점](#프레임워크와-라이브러리의-차이점)
    - [가비지 컬렉션이란](#가비지-컬렉션이란)
    - [Vector와 ArrayList의 차이는](#vector와-arraylist의-차이는)
    - [String과 StringBuffer의 차이는](#string과-stringbuffer의-차이는)
    - [Serialization이란](#serialization이란)
    - [Java의 메모리 영역은 (JVM 을 구성)](#java의-메모리-영역은-jvm-을-구성)
    - [오버로딩과 오버라이딩 차이는](#오버로딩과-오버라이딩-차이는)
    - [추상클래스와 인터페이스 차이는](#추상클래스와-인터페이스-차이는)
    - [제네릭](#제네릭)
    - [접근 지정자 4가지](#접근-지정자-4가지)
    - [Java 컴파일 과정 (안드로이드 컴파일 과정 추가)](#java-컴파일-과정-안드로이드-컴파일-과정-추가)
    - [C++ 실행 과정](#c-실행-과정)
    - [포인터를 이해하기 쉽도록 설명해주세요](#포인터를-이해하기-쉽도록-설명해주세요)
    - [Annotation](#annotation)
    - [jvm 역할](#jvm-역할)
    - [jvm 구조](#jvm-구조)
    - [CI/CD](#cicd)
    - [대용양 트래픽이 갑자기 발생했다. 어떻게 대응할꺼냐](#대용양-트래픽이-갑자기-발생했다-어떻게-대응할꺼냐)
    - [디자인 패턴](#디자인-패턴)
    - [디자인 패턴의 종류](#디자인-패턴의-종류)
    - [싱글톤 패턴](#싱글톤-패턴)
    - [그렇다면 대체 왜 전역 인스턴스 하나에 메모리를 할당하여 사용할까](#그렇다면-대체-왜-전역-인스턴스-하나에-메모리를-할당하여-사용할까)
    - [MVC 패턴](#mvc-패턴)
    - [MVC패턴의 장/단점](#mvc패턴의-장단점)
    - [MVP 패턴](#mvp-패턴)
    - [MVP패턴의 장/단점](#mvp패턴의-장단점)
    - [MVVM 패턴](#mvvm-패턴)
    - [MVVM 패턴의 장/단점](#mvvm-패턴의-장단점)

## 운영체제

운영체제란 Window, Linux, Mac os, ios, android 등 사용자가 컴퓨터를 사용하기 위한 추상화된 시스템을 말합니다.

### 프로세스와 스레드

1. 프로세스와 스레드 차이

   프로세스는 메모리 상에서 실행중인 프로그램을 말하며, 스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말한다. 프로세스마다 최소 하나의 스레드를 보유하고 있으며, 각각 별도의 주소공간을 독립적으로 할당받는다. (code, data, heap, stack) 스레드는 이중에 stack만 따로 할당받고 나머지 영역은 스레드끼리 서로 공유한다.
   `프로세스` : 자신만의 고유 공간과 자원을 할당받아 사용
   `스레드` : 다른 스레드와 공간과 자원을 공유하면서 사용

2. 멀티 프로세스로 처리 가능한 걸 굳이 멀티 스레드로 하는 이유는

   시스템 운영체제의 운영 기법 중 동시에 프로그램을 수행할 수 있는 CPU를 두 개 이상 두고 각각 그 업무를 분담하여 처리할 수 있는 방식을 의미하는 것은
   프로세스를 생성하여 `자원을 할당하는 시스템 콜`이 감소함으로써 자원의 효율적 관리가 가능함 (프로세스 생성 코스트가 적다)
   프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적어 작업들 간 부담이 감소함 (IPC 보다 스레드 간 통신 비용이 적다)
   대신, 멀티 스레드를 사용할 때는 공유 자원으로 인한 문제 해결을 위해 `동기화`에 신경써야 한다.

3. 사용자 수준 스레드 vs 커널 수준 스레드 차이는

   - 사용자 수준 스레드 - `ULT`

     장점 : 문맥 교환이 없어서 커널 스레드보다 오버헤드가 적음 (스레드 전환 시 커널 스케줄러 호출할 필요가 없기 때문)
     단점 : 프로세스 내의 한 스레드가 커널로 진입하는 순간, 나머지 스레드들도 전부 정지됨 (커널이 스레드의 존재를 알지 못하기 때문에)

   - 커널 수준 스레드 - `KLT`

     장점 : 사용자 수준 스레드보다 효율적임. 커널 스레드를 쓰면 멀티프로세서를 활용할 수 있기 때문이다. 사용자 스레드는 CPU가 아무리 많아도 커널 모드의 스케줄이 되지 않으므로, 각 CPU에 효율적으로 스레드 배당할 수가 없음
     단점 : 문맥 교환이 발생함. 이 과정에서 프로세서 모드가 사용자 모드와 커널 모드 사이를 움직이기 때문에 많이 돌아다닐 수록 성능이 떨어지게 된다.

   1. 프로세스의 스레드들을 몇몇 프로세서에 한꺼번에 디스패치 할 수 있기 때문에 멀티프로세서 환경에서 매우 빠르게 동작한다.
   2. 커널이 각 스레드를 개별적으로 관리할 수 있다.
   3. 커널이 직접 스레드를 제공해주기 때문에 안정성과 다양한 기능이 제공된다.
   4. 프로그래머 요청에 따라 스레드를 생성하고 스케줄링하는 주체가 커널이면 커널 레벨 스레드라고 한다.

#### 스레드 세이프 Thread safe

멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻한다

### 교착상태와 경쟁상태

1. 교착상태(DeadLock)가 무엇이며, 4가지 조건은

   프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 말한다.
   시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생하는 문제임

   - 상호배제 : 프로세스들이 필요로 하는 자원에 대해 배타적 통제권을 요구함
   - 점유대기 : 프로세스가 할당된 자원을 가진 상태에서 다른 자원 기다림
   - 비선점 : 프로세스가 어떤 자원의 사용을 끝날 때까지 그 자원을 뺏을 수 없음
   - 순환대기 : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있음

   이 4가지 조건 중 하나라도 만족하지 않으면 교착상태는 발생하지 않음 (순환대기는 점유대기와 비선점을 모두 만족해야만 성립합. 따라서 4가지가 서로 독립적이진 않음)

   - 데드락 피하는 알고리즘: 자원이 어떻게 요청될지에 대한 추가정보를 제공하도록 요구하는 것으로 시스템에 circular wait가 발생하지 않도록 자원 할당 상태를 검사한다.

   - 1. 자원 할당 그래프 알고리즘 (Resource Allocation Graph Algorithm)
   - 2. 은행원 알고리즘 (Banker’s algorithm)

2. 경쟁 상태란

   두 개 이상의 프로세스가 공통 자원을 병행적으로 읽거나 쓸 때, 공용 데이터에 대한 접근이 순서에 따라 실행 결과가 달라지는 상황
   Race Condition이 발생하게 되면, 모든 프로세스에 원하는 결과가 발생하는 것을 보장할 수 없음. 따라서 이러한 상황은 피해야 하며 상호배제나 임계구역으로 해결이 가능하다.

3. 기아 상태

컴퓨터 자원을 할당 받지 못해 계속해서 기다리는 상태

### 메모리 할당, 배치 교체

1. 메모리 할당 알고리즘 First fit, Next fit, Best fit 결과

   - First fit : 메모리의 처음부터 검사해서 크기가 충분한 첫번째 메모리에 할당
   - Next fit : 마지막으로 참조한 메모리 공간에서부터 탐색을 시작해 공간을 찾음
   - Best fit : 모든 메모리 공간을 검사해서 내부 단편화를 최소화하는 공간에 할당

2. 페이지 교체 알고리즘에 따른 페이지 폴트 방식

   - OPT : 최적 교체. 앞으로 가장 오랫동안 사용하지 않을 페이지 교체 (실현 가능성 희박)
   - FIFO : 메모리가 할당된 순서대로 페이지를 교체
   - LRU : 최근에 가장 오랫동안 사용하지 않은 페이지를 교체
   - LFU : 사용 빈도가 가장 적은 페이지를 교체
   - NUR : 최근에 사용하지 않은 페이지를 교체

### 페이징과 세그먼트

1. 외부 단편화와 내부 단편화란

   - 외부 단편화 : 작업보다 많은 공간이 있더라도 실제로 그 작업을 받아들일 수 없는 경우 (메모리 배치에 따라 발생하는 문제)

   - 내부 단편화 : 작업에 필요한 공간보다 많은 공간을 할당받음으로써 발생하는 내부의 사용 불가능한 공간

2. 가상 메모리란

   - 메모리에 로드된, 실행중인 프로세스가 메모리가 아닌 가상의 공간을 참조해 마치 커다란 물리 메모리를 갖는 것처럼 사용할 수 있게 해주는 기법

3. 페이징

   페이지 단위의 논리-물리 주소 관리 기법.
   논리 주소 공간이 하나의 연속적인 물리 메모리 공간에 들어가야하는 제약을 해결하기 위한 기법
   논리 주소 공간과 물리 주소 공간을 분리해야함(주소의 동적 재배치 허용), 변환을 위한 MMU 필요
   외부 단편화를 없앨 수 있음. 페이지가 클수록 내부 단편화도 커짐

4. 세그먼테이션

   사용자/프로그래머 관점의 메모리 관리 기법. 페이징 기법은 같은 크기의 페이지를 갖는 것 과는 다르게 논리적 단위(세그먼트)로 나누므로 미리 분할하는 것이 아니고 메모리 사용할 시점에 할당됨

### 뮤텍스, 세마포어가 뭔지, 차이점은

1. 세마포어

   운영체제에서 공유 자원에 대한 접속을 제어하기 위해 사용되는 신호, 공유자원에 접근할 수 있는 최대 허용치만큼만 동시에 사용자 접근 가능 스레드들은 리소스 접근 요청을 할 수 있고, 세마포어는 카운트가 하나씩 줄어들게 되며 리소스가 모두 사용중인 경우(카운트=0) 다음 작업은 대기를 하게 된다

2. 뮤텍스

   상호배제, 제어되는 섹션에 하나의 스레드만 허용하기 때문에, 해당 섹션에 접근하려는 다른 스레드들을 강제적으로 막음으로써 첫번재 스레드가 해당 섹션을 빠져나올 때까지 기다리는 것 (대기열(큐) 구조라고 생각하면 됨)

3. 차이점

   세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없음, 세마포어는 소유 불가능하지만, 뮤택스는 소유가 가능함
   동기화의 개수가 다름 하지만 차이점은 세마포어는 다른 프로세스에서 락을 해제할 수 있지만 뮤텍스는 그 프로세스에서 해제를 해야 한다는
   특성이 있습니다.

## 문맥교환

하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업
한 프로세스의 문맥은 그 프로세스의 PCB에 기록됨

멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때, 기존의 프로세스의 상태 또는 레지스터 값을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값을 교체하는 작업을 무엇이라고 할까 `문맥교환`

- Task의 대부분 정보는 Register에 저장되고 PCB(Process Control Block)로 관리된다.

- 현재 실행하고 있는 Task의 PCB 정보를 저장한다. (Process Stack, Ready Queue)

- 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행할 수 있다.

## 가상메모리란

프로세스에서 사용하는 메모리 주소와 실제 물리적 메모리 주소는 다를 수 있음
따라서 메모리 = 실제 + 가상 메모리라고 생각하면 안됨 메모리가 부족해서 가상메모리를 사용하는 건 맞지만, 가상메모리를 쓴다고 실제 메모리처럼 사용하는 것은 아님
실제 메모리 안에 공간이 부족하면, `현재 사용하고 있지 않은 데이터를 빼내어 가상 메모리에 저장해두고, 실제 메모리에선 처리만 하게 하는 것이 가상 메모리의 역할`이다.
즉, 실제 메모리에 놀고 있는 공간이 없게 계속 일을 시키는 것. 이를 도와주는 것이 '가상 메모리'

### 시스템 콜과 서브루틴

1. 리눅스에서 시스템 콜과 서브루틴의 차이는ㅇㅇㅇ
   커널은 하드웨어를 둘러싸고 있음
   즉, 커널은 하드웨어를 제어하기 위한 일종의 API와 같음
   서브루틴(SubRoutine)은 우리가 프로그래밍할 때 사용하는 대부분의 API를 얘기하는 것

2. 서브루틴과 시스템 콜의 차이는
   서브루틴이 시스템 콜을 호출하고, 시스템 콜이 수행한 결과를 서브루틴에 보냄
   시스템 콜 호출 시, 커널이 호출되고 커널이 수행한 임의의 결과 데이터를 다시 시스템 콜로 보냄
   서브루틴이 시스템 콜 호출 → 시스템 콜은 커널 호출 → 커널은 자신의 역할을 수행하고 (하드웨어를 제어함) 나온 결과 데이터를 시스템 콜에게 보냄 → 시스템 콜이 다시 서브루틴에게 보냄

## 데이터베이스

데이터베이스 관리 시스템 다수의 사용자가 데이터베이스 내의 데이터를 접근할 수 있도록 설계된 시스템

### DBMS 및 기능

- 정의 기능 DDL
  - 데이터베이스가 어떤 용도이며 어떤 식으로 이용될것이라는 것에 대한 정의가 필요함
  - CREATE, ALTER, DROP, RENAME
- 조작 기능 DML
  - 데이터베이스를 만들었을 때 그 정보를 수정하거나 삭제 추가 검색 할 수 있어야함
  - SELECT, INSERT, UPDATE, DELETE
- 제어 기능 DCL
  - 데이터베이스에 접근하고 객체들을 사용하도록 권한을 주고 회수하는 명령
  - GRANT REVOKE

### 인덱스 관련 내용

1. 키 값을 기초로 하여 테이블에서 검색과 정렬 속도를 향상시킨다.
2. 테이블의 기본키는 자동으로 인덱스가 된다.
3. 필드 중에는 데이터 형식 때문에 인덱스 될 수 없는 필드가 존재할 수 있다.
4. 인덱스 된 필드에서 데이터를 업데이트하거나, 레코드를 추가 또는 삭제할 때 성능이 떨어진다.

- 책에서 목차와 같은 역할
- DBMS에서 저장 성능을 희생하여 데이터 읽기 속도를 높이는 기능
- 데이터가 정렬되어 들어간다
- 양이 많은 테이블에서 일부 데이터만 불러 왔을 때, 이를 풀 스캔 시 처리 성능 떨어짐
  - B+-Tree 인덱스 : 원래의 값을 이용하여 인덱싱
  - Hash 인덱스 : 칼럼 값으로 해시 값 게산하여 인덱싱, 메모리 기반 DB에서 많이 사용
- 생성시 고려해야 할 점
  - 테이블 전체 로우 수 15%이하 데이터 조회시 생성
  - 테이블 건수가 적으면 인덱스 생성 하지 않음, 풀 스캔이 빠름
  - 자주 쓰는 컬럼을 앞으로 지정
  - DML시 인덱스에도 수정 작업이 동시에 발생하므로 DML이 많은 테이블은 인덱스 생성 하지 않음

### 데이터베이스 View 및 가상 테이블

허용된 데이터를 제한적으로 보여주기 위한 것 하나 이상의 테이블에서 유도된 가상 테이블이다.
사용자가 view에 접근했을 때 해당하는 데이터를 원본에서 가져온다. view에 나타나지 않은 데이터를 간편히 보호할 수 있는 장점 존재

### 정규화

삽입 이상, 삭제 이상, 갱신 이상을 제거하여 데이터를 구조화 시켜 데이터 중복을 최소화 한 것

1NF, 2NF, 3NF, BCNF, 4NF, 5NF, 6N

### 이상현상이란

릴레이션에서 일부 속성들의 종속으로 인해 데이터 중복이 발생

삽입 이상: 데이터를 삽입 시 불필요한 데이터까지 삽입
삭제 이상: 데이터 삭제 시 필요한 데이터까지 삭제
갱신 이상: 부분 데이터 변경시 데이터 불일치 현상

### 데이터베이스를 설계할 때 가장 중요한 것이 무엇이라고 생각하나요

무결성을 보장해야 합니다. 무결성은 테이블에 있는 모든 행들이 유일한 식별자를 가질 것을 요구함

외래키 값은 NULL이거나 참조 테이블의 PK값이어야 함 한 컬럼에 대해 NULL 허용 여부와 자료형, 규칙으로 타당한 데이터 값 지정

- 무결성 보장 방법
  데이터를 조작하는 프로그램 내에서 데이터 생성, 수정, 삭제 시 무결성 조건을 검증한다.
  트리거 이벤트 시 저장 SQL을 실행하고 무결성 조건을 실행한다. DB제약조건 기능을 선언한다.

### Commit과 Rollbak

- Commit : 하나의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산
- Rollback : 하나의 트랜잭션 처리가 비정상적으로 종료되어 DB의 일관성을 깨뜨렸을 때, 모든 연산을 취소시키는 연산

### 조인

2개 이상의 릴레이션을 연결하여 데이터를 만드는 것을 말한다.

1. A와 B테이블을 INNER Join하면 두 테이블이 모두 가지고 있는 데이터만 검색된다.
2. A와 B테이블이 서로 겹치지 않는 데이터가 4개 있을때, LEFT OUTER Join을 하면 결과값에 NULL은 4개 존재한다.
3. A LEFT JOIN B 와 B RIGHT JOIN A는 완전히 같은 식이다.
4. A 테이블의 개수가 6개, B 테이블의 개수가 4개일때, Cross Join을 하면, 결과의 개수는 24개이다

## 네트워크와 웹

### OSI 7계층

OSI 7계층이란, 통신 접속에서 완료까지의 과정을 7단계로 정의한 국제 통신 표준 규약

`물리` : 전송하는데 필요한 기능을 제공 ( 통신 케이블, 허브 )

`데이터링크` : 송/수신 확인. MAC 주소를 가지고 통신함 ( 브릿지, 스위치 )

`네트워크` : 패킷을 네트워크 간의 IP를 통해 데이터 전달 ( 라우팅 )

`전송` : 두 host 시스템으로부터 발생하는 데이터 흐름 제공

`세션` : 통신 시스템 사용자간의 연결을 유지 및 설정함

`표현` : 세션 계층 간의 주고받는 인터페이스를 일관성있게 제공

`응용` : 사용자가 네트워크에 접근할 수 있도록 서비스 제공

### TCP/IP 프로토콜을 스택 4계층으로 짓고 설명하시오

- LINK 계층
  물리적인 영역의 표준화에 대한 결과 가장 기본이 되는 영역으로 LAN, WAN과 같은 네트워크 표준과 관련된 프로토콜을 정의하는 영역이다

- IP 계층
  경로 검색을 해주는 계층임 IP 자체는 비연결지향적이며, 신뢰할 수 없는 프로토콜이다

데이터를 전송할 때마다 거쳐야할 경로를 선택해주지만, 경로가 일정하지 않음.

또한 데이터 전송 중에 경로상 문제가 발생할 때 데이터가 손실되거나 오류가 발생하는 문제가 발생할 수 있음.

따라서 IP 계층은 오류 발생에 대한 대비가 되어있지 않은 프로토콜임

- TCP/UDP (전송) 계층

데이터의 실제 송수신을 담당함

UDP는 TCP에 비해 상대적으로 간단하고, TCP는 신뢰성잇는 데이터 전송을 담당함

TCP는 데이터 전송 시, IP 프로토콜이 기반임 (IP는 문제 해결에 문제가 있는데 TCP가 신뢰라고)

→ IP의 문제를 해결해주는 것이 TCP인 것. 데이터의 순서가 올바르게 전송 갔는지 확인해주며 대화를 주고받는 방식임. 이처럼 확인 절차를 걸치며 신뢰성 없는 IP에 신뢰성을 부여한 프로토콜이 TCP이다

- 애플리케이션 계층

서버와 클라이언트를 만드는 과정에서 프로그램 성격에 따라 데이터 송수신에 대한 약속들이 정해지는데, 이것이 바로 애플리케이션 계층이다

### 서버와 클라이언트

서버와 클라이언트의 함수 호출 순서가 중요하다

`서버` : socket() 생성 → bind() 소켓 주소할당 → listen() 연결요청 대기상태 → accept() 연결허용 → read/write() 데이터 송수신 → close() 연결종료

`클라이언트` : socket() 생성 → connect() 연결요청 → read/write() 데이터 송수신 → close() 연결종료

서버와 클라이언트의 차이는 클라이언트 소켓을 생성한 후, 서버로 연결을 요청하는 과정에서 차이가 존재한다.

서버는 listen() 호출 이후부터 연결요청 대기 큐를 만들어 놓고, 그 이후에 클라이언트가 연결 요청을 할 수 있다. 이때 서버가 바로 accept()를 호출할 수 있는데, 연결되기 전까지 호출된 위치에서 블로킹 상태에 놓이게 된다.

### TCP란

이처럼 연결지향적인 TCP는 신뢰성 있는 데이터 전송이 가능함 연결 설정(`3-way handshaking`) , 연결 해제(`4-way handshaking`)

흐름제어와 혼잡제어를 지원해서 데이터 순서를 보장해줌

- 흐름제어 : 송신 측과 수신 측의 데이터 처리 속도 차이를 조절해주는 것
- 혼잡 제어 : 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것

정확성 높은 전송을 하기 위해 속도가 느린 단점, 주로 웹 HTTP 통신, 이메일, 파일 전송에 사용됨

### 3-way handshaking

TCP 소켓은 연결 설정과정 중에 총 3번의 대화를 주고 받는다.
(SYN : 연결 요청 플래그 / ACK : 응답)

- 클라이언트는 서버에 접속 요청하는 SYN(M) 패킷을 보냄
- 서버는 클라이언트 요청인 SYN(M)을 받고, 클라이언트에게 요청을 수락한다는 ACK(M+1)와 SYN(N)이 설정된 패킷을 발송함
- 클라이언트는 서버의 수락 응답인 ACK(M+1)와 SYN(N) 패킷을 받고, ACK(N+1)를 서버로 보내면 연결이 성립됨

A->B SYN : 접속요청, 랜덤한 시퀀스 번호 지정
B->A SYN + ACK : ACK 필드를 시퀀스 +1 지정하고, A에게 포트 개방 요청
A -> B: ACK : 요청 수락,

### TCP 4way 핸드쉐이킹(연결해제요청)

- 클라이언트가 연결 종료하겠다는 FIN 플래그를 전송함
- 서버는 클라이언트의 요청(FIN)을 받고, 알겠다는 확인 메시지로 ACK를 보냄. 그 이후 데이터를 모두 보낼 때까지 잠깐 TIME_OUT이 됨
- 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN플래그를 전송함
- 클라이언트는 FIN 메시지를 확인했다는 ACK를 보냄
- 클라이언트의 ACK 메시지를 받은 서버는 소켓 연결을 close함
- 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해서, 일정 시간동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거침 ( TIME_WAIT )

A->B FIN: 연결 해제 통보 :
B->A ACK : 일단 확인 메세지 전송, 자신의 통신이 끝날때까지 대기
B->A FIN : 통신 종료 후, A에게 연결 종료 합의 메세지 전송
A->B ACK : 프로세스 A가 확인했다는 메시지 전송

### TCP의 연결 설정 과정(3단계)과 연결 종료 과정(4단계)이 단계가 차이나는 이유

Client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문이다.

만약 Server에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까

이러한 현상에 대비하여 Client는 Server로부터 FIN 플래그를 수신하더라도 일정시간(Default: 240sec)동안 세션을 남겨 놓고 잉여 패킷을 기다리는 과정을 거친다. (TIME_WAIT 과정)

### UDP란

실제 데이터 단위를 받기 위해 IP를 사용함. 그러나 TCP와는 달리 메시지를 패킷으로 나누고, 반대편에서 재조립하는 등의 서비스를 제공하지 않음
즉, 여러 컴퓨터를 거치지 않고 데이터를 주고 받을 컴퓨터끼리 직접 연결할 때 UDP를 사용한다.

UDP를 사용해 목적지(IP)로 메시지를 보낼 수 있으며, 컴퓨터를 거쳐 목적지까지 도달할 수도 있음
(도착하지 않을 가능성도 존재함)

정보를 받는 컴퓨터는 포트를 열어두고, 패킷이 올 때까지 기다리며 데이터가 오면 모두 다 받아들인다. 패킷이 도착했을 때 출발지에 대한 정보(IP와 PORT)를 알 수 있음

UDP는 이런 특성 때문에 비신뢰적이고, 안정적이지 않은 프로토콜임. 하지만 TCP보다 속도가 매우 빠르고 편해서 데이터 유실이 일어나도 큰 상관이 없는 스트리밍이나 화면 전송에 사용됨

혹시나 사용을 하게 된다면 QUIC (Quick UDP Internet Connection) 을 사용하는 방법을 추천
celluar 환경에서 wifi 에 환경으로 넘어가는 경우 어떻게 동작을 하는 것이 현명한가 UDP 중에서 Google 에서 개발을 하고 있는 Quic 이 좋다고 알고 있다.

### TCP/UDP 차이

TCP : 연결형 서비스 , 3way, 4way 핸드 세이킹(신뢰성 보장), UDP보다 느림
UDP : 비연결형 서비스, TCP보다 빠름, 최소한의 오류 검출, 실식나 서비스같이 연속성이 중요한 경우 사용

### HTTP와 HTTPS의 차이는

웹 통신 프로토콜인 HTTP의 보안이 강화된 버전의 프로토콜 따라서 데이터의 적절한 보호를 보장한다
사용자의 데이터를 공개키로 암호화 (공개키를 얻은 인증된 사용자) 서버의 개인키를 통해 복호화하여 요청 처리

1. http는 웹상에서 클라이언트와 웹서버간 통신을 위한 프로토콜 중 하나이다.
2. http/1.1은 기본적으로 Connection 당 하나의 요청을 처리하도록 설계되어있다.
3. http/2.0은 헤더 압축으로 http/1.1보다 빠르다
4. http/2.0은 한 커넥션으로 동시에 여러 메시지를 주고 받을 수 있다.

HTTP 동작 순서 : TCP → HTTP

HTTPS 동작 순서 : TCP → SSL → HTTP

SSL(Secure Socket Layer)을 쓰냐 안쓰냐의 차이다. SSL 프로토콜은 정보를 암호화시키고 이때 공개키와 개인키 두가지를 이용한다. 혹은 TLS(transport layer security) 를 사용해야 한다.

HTTPS는 인터넷 상에서 정보를 암호화하기 위해 SSL 프로토콜을 이용해 데이터를 전송하고 있다는 것을 말한다. 즉, 문서 전송시 암호화 처리 유무에 따라 HTTP와 HTTPS로 나누어지는 것

모든 사이트가 HTTPS로 하지 않는 이유는, 암호화 과정으로 인한 속도 저하가 발생하기 때문이다. 또한, SSL을 넘어서 사용하고 있는 TLS 프로토콜을 이용하여 HTTPS 를 지원을 한다.

|     |                                          설명                                          |
| :-: | :------------------------------------------------------------------------------------: |
| 100 |      Continue (클라이언트로 부터 일부 요청을 받았으며 나머지 정보를 계속 요청함)       |
| 101 |                                  Switching protocols                                   |
| 200 |                            OK(요청이 성공적으로 수행되었음)                            |
| 201 |                 Created (PUT 메소드에 의해 원격지 서버에 파일 생성됨)                  |
| 202 |                            Accepted(웹 서버가 명령 수신함)                             |
| 203 |         Non-authoritative information (서버가 클라이언트 요구 중 일부만 전송)          |
| 204 |              No content, (사용자 요구 처리하였으나 전송할 데이터가 없음)               |
| 301 |               Moved permanently (요구한 데이터를 변경된 타 URL에 요청함)               |
| 302 |                                    Not temporarily                                     |
| 304 | Not modified (컴퓨터 로컬의 캐시 정보를 이용함, 대개 gif 등은 웹 서버에 요청하지 않음) |
| 400 |                  Bad request (사용자의 잘못된 요청을 처리할 수 없음)                   |
| 401 |                   Unauthorized (인증이 필요한 페이지를 요청한 경우)                    |
| 402 |                                Payment required(예약됨)                                |
| 403 |      Forbidden (접근 금지, 디렉터리 리스팅 요청 및 관리자 페이지 접근 등을 차단)       |
| 404 |                            Not found, (요청한 페이지 없음)                             |
| 405 |                 Method not allowed (혀용되지 않는 http method 사용함)                  |
| 407 |                   Proxy authentication required (프락시 인증 요구됨)                   |
| 408 |                            Request timeout (요청 시간 초과)                            |
| 410 |                              Gone (영구적으로 사용 금지)                               |

100: 정보 전달, 작업 진행 중
200: 작업 성공
300: 리다이렉션이 일어남
400: 클라이언트 잘못
500: 서버 잘못

HTTP 요청 응답 헤더

일반헤더

Date
Connection
Content-Type
Content-Language
Content-Encoding : 해당 개체 데이터의 압축 방식
Last-Modified
요청헤더

Host: 요청하는 호스트에 대한 호스트명 및 포트번호 (필수)
User-Agent : 클라이언트 소프트웨어(브라우저, OS) 명칭 및 버전 정보
Cookie :서버에 의해 Set-Cookie로 클라이언트에게 설정된 쿠키 정보
Referer :바로 직전에 머물었던 웹 링크 주소a
Origin : 서버로 POST 요청을 보낼 때, 요청이 어느 주소에서 시작되었는지 나타냄
Accept: 클라이언트 자신이 원하는 미디어 타입 및 우선순위를 알림
Accept-Charset:
응답헤더

Server: 서버 소프트웨어 정보
Set-Cookie: 서버측에서 클라이언트에게 세션 쿠키 정보를 설정 (RFC 2965에서 규정)

### GET과 POST ()

HTTP메소드는 GET(), POST(), PUT(), DELETE()
둘다 HTTP 프로토콜을 이용해 서버에 무언가 요청할 때 사용하는 방식이다.

GET 방식은, URL을 통해 모든 파라미터를 전달하기 때문에 주소창에 전달 값이 노출됨. URL 길이가 제한이 있기 때문에 전송 데이터 양이 한정되어 있고, 형식에 맞지 않으면 인코딩해서 전달해야 함

POST 방식은 HTTP BODY에 데이터를 포함해서 전달함. 웹 브라우저 사용자의 눈에는 직접적으로 파라미터가 노출되지 않고 길이 제한도 없음.

- GET()은 SELECT 성향이 있어서 서버에서 어떤 데이터를 가져와서 보여주는 용도로 활용
- POST()는 서버의 값이나 상태를 바꾸기 위해 활용

### GET()

`URL에 요청 정보를 붙여서 전송`한다.
URL에 요청 정보가 이어붙기 때문에 길이 제한이 있어서 대용량의 데이터를 전송하기 어렵다
요청 정보를 사용자가 쉽게 눈으로 확인할 수 있다.
HTTP 패킷의 Body는 비어 있는 상태로 전송한다.
POST 방식보다 빠르다

### POST()

요청 정보를 HTTP 패킷의 Body 안에 숨겨서 서버로 전송한다.
Request Header의 Content-Type에 해당 데이터 타입이 표현되며, 전송하고자 하는 데이터 타입을 적어주어야 한다
Body 안에 숨겨서 요청 정보를 전송하기 때문에 대용량의 데이터를 전송하기에 적합하다.
클라이언트 쪽에서 데이터를 인코딩하여 서버로 전송하고, 이를 받은 서버 쪽이 해당 데이터를 디코딩한다. `GET 방식보다 보안상 안전하다.`

### 조회하기 위한 용도 POST가 아닌 GET 방식을 사용하는 이유

설계 원칙에 따라 GET 방식은 서버에게 여러 번 요청을 하더라도 동일한 응답이 돌아와야 한다
GET 방식은 가져오는 것(Select) 으로, 서버의 데이터나 상태를 변경시키지 않아야 한다.
POST 방식은 수행하는 것 으로, 서버의 값이나 상태를 바꾸기 위한 용도이다

웹에서 모든 리소스는 Link할 수 있는 URL을 가지고 있어야 한다
즉, 어떤 웹페이지를 조회할 때 원하는 페이지로 바로 이동하거나 이동시키기 위해서는 해당 링크의 정보가 필요하다.
링크를 통해 특정 페이지로 바로 이동하려면 해당 링크와 관련된 정보가 필요한데 POST는 요청 데이터가 Body에 담겨 있기 때문에 링크 정보를 가져올 수 없습니다

### 네트워크 장비

허브는 컴퓨터를 연결을 해주는 장비 이지만 MAC 을 기억하지 않는다.

스위치는 주로 내부 네트워크에 위치하며 MAC 주소 테이블을 이용해 해당 프레임을 전송하는 2계층 장비

라우터는 3계층 장비로, 수신한 패킷의 정보를 보고 경로를 설정해 패킷을 전송하는 역할을 수행하는 장비

### 쿠키 세션

1. 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송한다.
2. 세션은 쿠키를 사용한다.
3. 보안 면에서는 쿠키보다 세션이 더 우수하며, 요청 속도를 쿠키가 세션보다 빠르다.
4. 세션은 쿠키와 달리 서버 측에서 관리한다. (세션은 서버, 쿠키 클라이언트)

### 쿠키

HTTP 프로토콜은 위와 같은 특징으로 모든 요청 간 의존관계가 없다.
클라이언트 로컬에 저장되는 키와 값이 들어있는 파일이다.

- 쿠키의 이름(name)
- 쿠키의 값(value)
- 쿠키의 만료시간(Expires)
- 쿠키를 전송할 도메인 이름(Domain)
- 쿠키를 전송할 경로(Path)
- 보안 연결 여부(Secure)
- HttpOnly 여부(HttpOnly)

만료시간에 따라 브라우저를 종료해도 계속해서 남아 있을 수 있다.

### 세션

일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술이다.
서버가 해당 웹브라우저(클라이언트)에 유일한 ID(Session ID)를 부여함
서버가 응답할 때 HTTP 헤더(Set-Cookie)에 Session ID를 포함해서 전송
쿠키에 Session ID를 JSESSIONID 라는 이름으로 저장
서버는 세션 ID를 확인하고, 해당 세션에 관련된 정보를 확인한 후 응답
만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.

### REST와 RESTful의 개념

'애플리케이션 분리 및 통합', '다양한 클라이언트의 등장'

다양한 클라이언트와 통신할 수 있는 서버와 클라이언트 통신 방식

"Representational State Transfer(대표적인 상태 전달)"의 약자
분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식

REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다.

HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(Post, Get, Put, Delete)를 통해 해당 자원에 대한 CRUD 을 적용하는 것을 의미한다.
즉, REST는 자원 기반의 구조(ROA, Resource Oriented Architecture) 설계의 중심에 Resource가 있고 HTTP Method를 통해 Resource를 처리하도록 설계된 아키텍쳐를 의미한다.
웹 사이트의 이미지, 텍스트, DB 내용 등의 모든 자원에 고유한 ID인 HTTP URI를 부여한다.

- 장점
  여러 가지 서비스 디자인에서 생길 수 있는 문제를 최소화해준다.
  Hypermedia API의 기본을 충실히 지키면서 범용성을 보장한다.
  HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해준다.

- 단점
  브라우저를 통해 테스트할 일이 많은 서비스라면 쉽게 고칠 수 있는 URL보다 Header 값이 왠지 더 어렵게 느껴진다.
  구형 브라우저가 아직 제대로 지원해주지 못하는 부분이 존재한다.
  pushState를 지원하지 않는 점

#### REST 구성 요소

자원(Resource): URI
모든 자원에 고유한 ID가 존재하고, 이 자원은 Server에 존재한다.
자원을 구별하는 ID는 '/groups/:group_id'와 같은 HTTP URI 다.
Client는 URI를 이용해서 자원을 지정하고 해당 자원의 상태(정보)에 대한 조작을 Server에 요청한다.

행위(Verb): HTTP Method
HTTP 프로토콜의 Method를 사용한다.
HTTP 프로토콜은 GET, POST, PUT, DELETE, HEAD 와 같은 메서드를 제공한다.

표현(Representation of Resource)
Client가 자원의 상태(정보)에 대한 조작을 요청하면 Server는 이에 적절한 응답(Representation)을 보낸다. REST에서 하나의 자원은 JSON, XML, TEXT, RSS 등 여러 형태의 Representation으로 나타내어 질 수 있다. JSON 혹은 XML를 통해 데이터를 주고 받는 것이 일반적이다.

### REST 특징

Server-Client(서버-클라이언트 구조)
Stateless(무상태)
Cacheable(캐시 처리 가능)
Layered System(계층화)
Code-On-Demand(optional)
Uniform Interface(인터페이스 일관성)

### REST API

REST 기반으로 서비스 API를 구현한 것
최근 OpenAPI(누구나 사용할 수 있도록 공개된 API: 구글 맵, 공공 데이터 등), 마이크로 서비스(하나의 큰 애플리케이션을 여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처) 등을 제공하는 업체 대부분은 REST API를 제공한다.

### REST API의 특징

사내 시스템들도 REST 기반으로 시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다.
REST는 HTTP 표준을 기반으로 구현하므로, HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현할 수 있다.
즉, REST API를 제작하면 델파이 클라이언트 뿐 아니라, 자바, C#, 웹 등을 이용해 클라이언트를 제작할 수 있다.
REST API 설계 기본 규칙
URI는 정보의 자원을 표현해야 한다.
resource는 동사보다는 명사를 사용한다.
resource는 영어 소문자 복수형을 사용하여 표현한다.
Ex) GET /Member/1 -> GET /members/1
자원에 대한 행위는 HTTP Method(GET, PUT, POST, DELETE 등)로 표현한다.
URI에 HTTP Method가 들어가면 안된다.
Ex) GET /members/delete/1 -> DELETE /members/1
URI에 행위에 대한 동사 표현이 들어가면 안된다.
Ex) GET /members/show/1 -> GET /members/1
Ex) GET /members/insert/2 -> POST /members/2
REST API 설계 규칙
슬래시 구분자(/ )는 계층 관계를 나타내는데 사용한다.
Ex) <http://restapi.example.com/houses/apartments>
URI 마지막 문자로 슬래시(/ )를 포함하지 않는다.
URI에 포함되는 모든 글자는 리소스의 유일한 식별자로 사용되어야 하며 URI가 다르다는 것은 리소스가 다르다는 것이고, 역으로 리소스가 다르면 URI도 달라져야 한다.
REST API는 분명한 URI를 만들어 통신을 해야 하기 때문에 혼동을 주지 않도록 URI 경로의 마지막에는 슬래시(/)를 사용하지 않는다.
하이픈(- )은 URI 가독성을 높이는데 사용
불가피하게 긴 URI경로를 사용하게 된다면 하이픈을 사용해 가독성을 높인다.
밑줄(\_ )은 URI에 사용하지 않는다.
밑줄은 보기 어렵거나 밑줄 때문에 문자가 가려지기도 하므로 가독성을 위해 밑줄은 사용하지 않는다.
URI 경로에는 소문자가 적합하다.
URI 경로에 대문자 사용은 피하도록 한다.
RFC 3986(URI 문법 형식)은 URI 스키마와 호스트를 제외하고는 대소문자를 구별하도록 규정하기 때문
파일확장자는 URI에 포함하지 않는다.
REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함시키지 않는다.
Accept header를 사용한다.
Ex) http://restapi.example.com/members/soccer/345/photo.jpg (X)
Ex) GET / members/soccer/345/photo HTTP/1.1 Host: restapi.example.com Accept: image/jpg (O)
리소스 간에는 연관 관계가 있는 경우
/리소스명/리소스 ID/관계가 있는 다른 리소스명
Ex) GET : /users/{userid}/devices (일반적으로 소유 ‘has’의 관계를 표현할 때)
:id는 하나의 특정 resource를 나타내는 고유값
Ex) student를 생성하는 route: POST /students
Ex) id=12인 student를 삭제하는 route: DELETE /students/12

### RESTful

RESTful은 일반적으로 REST라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어이다.
즉, REST 원리를 따르는 시스템은 RESTful이란 용어로 지칭된다.
RESTful은 REST를 REST답게 쓰기 위한 방법으로, 누군가가 공식적으로 발표한 것이 아니다.

#### RESTful의 목적

이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것
RESTful API를 구현하는 근본적인 목적이 퍼포먼스 향상에 있는게 아니라, 일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는게 주 동기이니, 퍼포먼스가 중요한 상황에서는 굳이 RESTful API를 구현하실 필요는 없습니다.
RESTful 하지 못한 경우
Ex1) CRUD 기능을 모두 POST로만 처리하는 API
Ex2) route에 resource, id 외의 정보가 들어가는 경우(/students/updateName)

### RESTful 하게 API 를 디자인 한다는 것은 무엇을 의미하는가.(요약)

1. `리소스` 와 `행위` 를 명시적이고 직관적으로 분리한다.

   - 리소스는 `URI`로 표현되는데 리소스가 가리키는 것은 `명사`로 표현되어야 한다.
   - 행위는 `HTTP Method`로 표현하고, `GET(조회)`, `POST(생성)`, `PUT(기존 entity 전체 수정)`, `PATCH(기존 entity 일부 수정)`, `DELETE(삭제)`을 분명한 목적으로 사용한다.

2. Message 는 Header 와 Body 를 명확하게 분리해서 사용한다.

   - Entity 에 대한 내용은 body 에 담는다.
   - 애플리케이션 서버가 행동할 판단의 근거가 되는 컨트롤 정보인 API 버전 정보, 응답받고자 하는 MIME 타입 등은 header 에 담는다.
   - header 와 body 는 http header 와 http body 로 나눌 수도 있고, http body 에 들어가는 json 구조로 분리할 수도 있다.

3. API 버전을 관리한다.

   - 환경은 항상 변하기 때문에 API 의 signature 가 변경될 수도 있음에 유의하자.
   - 특정 API 를 변경할 때는 반드시 하위호환성을 보장해야 한다.

4. 서버와 클라이언트가 같은 방식을 사용해서 요청하도록 한다.

   - 브라우저는 form-data 형식의 submit 으로 보내고 서버에서는 json 형태로 보내는 식의 분리보다는 json 으로 보내든, 둘 다 form-data 형식으로 보내든 하나로 통일한다.
   - 다른 말로 표현하자면 URI 가 플랫폼 중립적이어야 한다.

- 장점

1. Open API 를 제공하기 쉽다
2. 멀티플랫폼 지원 및 연동이 용이하다.
3. 원하는 타입으로 데이터를 주고 받을 수 있다.
4. 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다.

- 단점

1. 분산환경에는 부적합하다.
2. HTTP 통신 모델에 대해서만 지원한다.

### WebSocket

페이지의 한계에서 벗어나 실시간으로 상호작용하는 웹 서비스를 만드는 표준 기술HTTP 프로토콜은 클라이언트에서 서버로의 단방향 통신을 위해 만들어진 방법이다.
실시간 웹을 구현하기 위해서는 양방향 통신이 가능해야 하는데, WebSocket 이전에는 Polling, Streaming 방식의 AJAX 코드를 이용하여 이를 구현하였다.
하지만 이 방법들을 이용하면 각 브라우저마다 구현 방법이 달라 개발이 어렵다는 문제점이 있었다.
이를 위해 HTML5 표준의 일부로 WebSocket이 만들어지게 되었다.

### 일반 TCP Socket과의 차이점

일반 HTTP Request를 통해 handshaking 과정을 거쳐 최초 접속이 이루어진다.

소켓을 이용하여 자유롭게 데이터를 주고 받을 수 있다.
기존의 요청-응답 관계 방식보다 더 쉽게 데이터를 교환할 수 있다.
다른 HTTP Request와 마찬가지로 80포트를 통해 웹 서버에 연결한다.
http:// 대신 ws:// 로 시작하며 Streaming과 유사한 방식으로 푸쉬를 지원한다.
클라이언트인 브라우저와 마찬가지로 웹 서버도 WebSocket 기능을 지원해야 한다. (WebSocket을 지원하는 여러 서버 구현체(Jetty, GlassFish, Node.js, Netty, Grizzly 등)가 있다.)
클라이언트인 브라우저 중에서는 Chrome, Safari, Firefox, Opera에서 WebSocket을 사용할 수 있으며, 각종 모바일 브라우저에서도 WebSocket을 사용할 수 있다.
WebSocket 프로토콜은 아직 확정된 상태가 아니기 때문에 브라우저별로 지원하는 WebSocket 버전이 다르다. (예전 브라우저는 지원하지 않는다.)
즉, WebSocket은 다가올 미래의 기술이지 아직 인터넷 기업에서 시범적으로라도 써 볼 수 있는 기술이 아니다.

- 장점

HTTP Request를 그대로 사용하기 때문에 기존의 80, 443포트로 접속을 하므로 추가로 방화벽을 열지 않고도 양방향 통신이 가능하다.
HTTP 규격인 CORS 적용이나 인증 등의 과정을 기존과 동일하게 사용할 수 있다.

### Socket.io

다양한 방식의 실시간 웹 기술을 손쉽게 사용할 수 있는 모듈 (웹 클라이언트로의 푸쉬를 지원하는 모듈)
WebSocket, FlashSocket, AJAX Long Polling, AJAX Multi part Streaming, IFrame, JSONP Polling 등 다양한 방법을 하나의 API로 추상화한 것이다.
즉, Socket.io는 JavaScript를 이용하여 브라우저 종류에 상관없이 실시간 웹을 구현할 수 있도록 한 기술이다.

Socket.io는 현재 바로 사용할 수 있는 기술이다.
WebSocket 프로토콜은 IETF에서 관장하는 표준 프로토콜이라서 WebSocket을 지원하는 여러 서버 구현체(Jetty, GlassFish, Node.js, Netty, Grizzly 등)가 있지만 Socket.io는 Node.js 하나 밖에 없다.

- 장점

개발자는 Socket.io로 개발을 하고 클라이언트로 푸쉬 메시지를 보내기만 하면, WebSocket을 지원하지 않는 브라우저의 경우는 브라우저 모델과 버전에 따라서 AJAX Long Polling, MultiPart Streaming, Iframe을 이용한 푸쉬, JSONP Polling, Flash Socket 등 다양한 방법으로 내부적으로 푸쉬 메시지를 보내준다.
즉, WebSocket을 지원하지 않는 어느 브라우져라도 푸쉬 메시지를 일관된 모듈로 보낼 수 있다.

### 대용량 트래픽 처리 관련 이슈

[로드 밸런서 관련 내용]<https://post.naver.com/viewer/postView.nhnvolumeNo=27046347&memberNo=2521903>
[네이버 로드 밸런서]<https://d2.naver.com/helloworld/6070967>

## 자료구조와 알고리즘

### 일치하는 자료구조 작성하기

1. 문자열이 주어지고 빠른 검색 ~~ : Hash
2. 운영체제 라운드 로빈에서 사용 ~~ : LinkedList
3. 우선순위로 뽑고 ~~~ : 우선순위 큐 (Heap)
4. 후위연산하는 ~~ : Stack

5. 이진트리

Tree node size 구하기 : left + right + 1
Tree node depth 구하기 : max(left, right) + 1

### BFS 를 쓰는 방법

```c++
#include <queue
#include <vector

bool visited[101];
vector<intmap[101];

void bfs(int a){
   queue<intq;
   visited[a] = 1;
   while(!q.empty()){
      int x = q.front();
      q.pop();

      for(auto ele :map[x]){
         if(!visited[ele]){
            visited[ele] = 1;
            q.push(ele);
         }
      }
   }
}
```

### 이진탐색

```c++
if(arr[mid] < value) {
    1) start = mid + 1;
}
else(arr[mid] value) {
    1) end = mid - 1;
}
```

binary_search(), lower_bound() -LIS, upper_bound()
O(nlogn) 이진탐색으로 최적화할 수 있다.

### 정렬 알고리즘 정리

이름: 퀵 정렬 최적 O(nlogn) 최악 n^2 untable 정렬
이름: 병합 정렬 최적 nlogn 최악 nlogn stable 정렬

### 해시란

데이터 삽입 및 삭제 시, 기존 데이터를 밀어내거나 채우지 않고 데이터와 연관된 고유한 숫자를 생성해 인덱스로 사용하는 방법
검색 속도가 매우 빠르다

평균 시간 복잡도 O(1) 에서 탐색을 할 수 있으나 충돌의 경우 O(n) 까지 늘어날 수 있습니다.

#### HashMap, TreeMap, LinkedHashMap

HashMap은 내부 hashing된 값에 따라 키 순서가 정해지므로 key는 특정 순서 없이 나온다.
TreeMap은 내부적으로 RedBlack Tree로 저장됨, 키값에 대한 Compartor 구현으로 정렬 순서를 바꿀수 있다. 정렬된 순서로 key 값이 나온다.
LinkedHashMap은 내부적으로 LinkedList, 입력 순서대로 key 값이 나온다.

키에 대한 해시 값을 사용하여 값을 저장하고 조회하며, 키-값 쌍의 개수에 따라 동적으로 크기가 증가하는 associate array라고 할 수 있다. 이 associate array를 지칭하는 다른 용어가 있는데, 대표적으로 Map, Dictionary, Symbol Table 등이다.
해시함수를 통해 얻은 해시코드 값이 두 개 이상 같은 경우 해시의 충돌이 발생한다.

충돌은 아무리 해시 함수를 잘 구현하더라도 필연적으로 발생할 수 밖에 없다.
이렇듯 발생하는 충돌에 대해서 해시 충돌이 발생하더라도 키-값 쌍 데이터를 잘 저장하고 조회할 수 있게 하는 방식에는 대표적으로 두가지가 존재하는데 하나는 Open Addressing이고, 다른 하나는 Separate Chaining이다.
Open Addressing은 데이터를 삽입하려는 해시 버킷이 이미 사용 중인 경우 다른 해시 버킷에 해당 데이터를 삽입하는 방식이다.

- 선형 탐색(Linear Probing): 해시충돌 시 다음 버켓, 혹은 몇 개를 건너뛰어 데이터를 삽입한다.
- 제곱 탐색(Quadratic Probing): 해시충돌 시 제곱만큼 건너뛴 버켓에 데이터를 삽입(1,4,9,16..)
- 이중 해시(Double Hashing): 해시충돌 시 다른 해시함수를 한 번 더 적용한 결과를 이용함.

Separate Chaining에서 각 배열의 인자는 인덱스가 같은 해시 버킷을 연결한 링크드 리스트의 첫 부분(head)이다.
Java HashMap에서 사용하는 방식은 Separate Channing이다. Open Addressing은 데이터를 삭제할 때 처리가 효율적이기 어려운데, HashMap에서 remove() 메서드는 매우 빈번하게 호출될 수 있기 때문이다. 둘 모두 Worst Case O(M) 이며 자세한 설명한 생략한다.

### 트리

### Max Heap, Min Heap, 우선순위 큐

### 최단 경로 알고리즘 다익스트라(우선 순위 큐), 플로이드 와샬(다이나믹)

### MST 알고리즘 크루스칼(유니온, 파인드), 프림 알고리즘(우선 순위 큐)

1. 배열과 연결리스트 차이는

배열은 인덱스를 가짐. 원하는 데이터를 한번에 접근하기 때문에 접근 속도 빠름.

크기 변경이 불가능하며, 데이터 삽입 및 삭제 시 그 위치의 다음 위치부터 모든 데이터 위치를 변경해야 되는 단점 존재

연결리스트는 인덱스 대신에 현재 위치의 이전/다음 위치를 기억함.

크기는 가변적. 인덱스 접근이 아니기 때문에 연결되어 있는 링크를 쭉 따라가야 접근이 가능함. (따라서 배열보다 속도 느림)

데이터 삽입 및 삭제는 논리적 주소만 바꿔주면 되기 때문에 매우 용이함

데이터의 양이 많고 삽입/삭제가 없음. 데이터 검색을 많이 해야할 때 → Array

데이터의 양이 적고 삽입/삭제 빈번함 → LinkedList

### Stack, Queue

## 언어, 코드 및 기타

1. Java와 Javascript의 차이
2. 데브옵스, CI, CD

## 객체 지향 프로그래밍

1. OOP는 유지 보수성, 재사용성, 확장성이라는 장점이 있다.
2. 캡슐화는 만일의 상황(타인이 외부에서 조작)을 대비해서 외부에서 특정 속성이나 메서드를 시용자가 사용할 수 없도록 숨겨놓은 것이다.
3. 다형성은 부모클레스에서 물려받은 가상 함수를 자식 클래스 내에서 오버라이딩 되어 사용되는 것이다.
4. 객체는 소프트웨어 세계에 구현할 대상이고, 이를 구현하기 위한 설계도가 클래스이며, 이 설계도에 따라 소프트웨어 세계에 구현된 실체가 인스턴스다.

객체 지향 프로그래밍 이전의 프로그래밍 패러다임을 살펴보면, 중심이 컴퓨터에 있었다. 컴퓨터가 사고하는대로 프로그래밍을 하는 것이다. 하지만 객체지향 프로그래밍이란 인간 중심적 프로그래밍 패러다임이라고 할 수 있다. 즉, 현실 세계를 프로그래밍으로 옮겨와 프로그래밍하는 것을 말한다. 현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍 하는 것이다. 이것을 추상화라한다.

OOP 로 코드를 작성하면 이미 작성한 코드에 대한 재사용성이 높다. 자주 사용되는 로직을 라이브러리로 만들어두면 계속해서 사용할 수 있으며 그 신뢰성을 확보 할 수 있다. 또한 라이브러리를 각종 예외상황에 맞게 잘 만들어두면 개발자가 사소한 실수를 하더라도 그 에러를 컴파일 단계에서 잡아낼 수 있으므로 버그 발생이 줄어든다. 또한 내부적으로 어떻게 동작하는지 몰라도 개발자는 라이브러리가 제공하는 기능들을 사용할 수 있기 때문에 생산성이 높아지게 된다. 객체 단위로 코드가 나눠져 작성되기 때문에 디버깅이 쉽고 유지보수에 용이하다. 또한 데이터 모델링을 할 때 객체와 매핑하는 것이 수월하기 때문에 요구사항을 보다 명확하게 파악하여 프로그래밍 할 수 있다.

객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 overhead 가 발생하게 된다. 하지만 이것은 하드웨어의 발전으로 많은 부분 보완되었다. 객체 지향 프로그래밍의 치명적인 단점은 함수형 프로그래밍 패러다임의 등장 배경을 통해서 알 수 있다. 바로 객체가 상태를 갖는다는 것이다. 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생시킨다는 것이다. 이러한 이유로 함수형 패러다임이 주목받고 있다.

### 프레임워크

프로그램 개발에 투입되는 개발자들이 늘어남에 따라서(특히 객체 지향 프로그래밍이 늘어남에 따라서) 다양성 또한 비례되어 늘어나고, 전체 시스템의 통합성, 일관성이 부족함을 느끼게 되었다. 그래서 개발자의 자유를 제한하는 대신에 일정한 테두리 안에서 일관되고 유지 보수를 쉽게 개발할 수 있는 환경인 프레임워크를 도입했다.

기본적인 뼈대가 이미 완성되어 있고 규칙이 존재하는 개발 환경

한마디로 정의하자면 위와 같다. 쉽게 예를 들자면 자동차의 뼈대가 있다면 이 뼈대를 기초로해서 세단이나 쿠페, SUV 등 외형을 덫붙혀 자동차를 완성하게 된다.

이 뼈대의 역할을 프레임워크가 하고있고 외형적인 네비게이션이나 내장장식, 유리창 등 라이브러리를 가져와서 사용해 붙일 수 있다.

특정한 틀을 만들어놓고 거기에 살을 붙여 놓음으로써 프로그램을 만들 때 작업시간을 줄여주는 것이다. 이를 스켈레톤 코드라고도 하는데, 뼈대가 이미 만들어져 있어서 거기에 살만 덧붙이면 완성이 되도록 공통된 함수 또는 클래스를 미리 만들어 놓는 것을 이야기한다.

따라서 프레임워크는 다음과 같은 특징을 가진다.

1. 개발자들이 따라야 할 가이드라인을 가진다.
2. 개발할 수 있는 범위가 정해져 있다.
3. 개발자를 위한 다양한 도구들이 지원된다.

### 프레임워크 사용의 장/단점

- 장점

1. 개발편의성이 올라서, 시간을 줄일 수 있다.
2. 오류의 폭을 좁힐 수 있다.
3. 어느 정도의 코드 품질을 보장한다.
4. 유지 보수하기 좋다.

- 단점

1. 프레임워크의 의존도가 늘어나 개발 능력이 저하될 수 있다.
2. 개발자의 자유도가 떨어진다.

### 라이브러리

프로그래밍을 하게되면서 공통적으로 반복적으로 사용되는 기능들이나 특정한 기능들을 부딪히게 되고 그때마다 새로 알고리즘을 짜거나 새로 코딩을 하는 것보다 잘 만들어진 모듈화된 코드를 가져다 쓰는 것이 훨씬 간편하고 안정적이라는 필요와 수요가 생기면서 만들어졌다.

> 개발 시 활용가능한 도구들을 모아 모듈화한 것

여러 회사들 중에 잘 만든 네비게이션이나 라디오가 있다고 하자. 그렇다면 우리는 하나하나 라디오나 네비게이션을 처음부터 만드는 것이 아니라, 만드는 자동차에 이미 만들어진 이들 네비게이션이나 라디오들을 원하는 곳에 설치만 하면 된다. 다시 돌아와서 설명하자면 여러 라이브러리들 중에서 우리가 원하는 함수, 클래스들만 가져다쓰면 되는 것이다.

### 라이브러리와 API의 차이점

여기서 API(Application Programming Interface)랑 햇갈릴 수가 있는데, 라이브러리는 실제로 실행이 되는 기능을 담당하는 단편화된 프로그램이고 API는 다른 목적으로 개발된 프로그램/라이브러리 들의 특정 기능을 호출하기 위해서 인터페이스를 노출시킨 것이 API다. 따라서 특정한 부분만을 수행하며 API자체로는 사용자가 직접적으로 일반적인 조작을 할 수 없다.
예를 들어 네이버 지도를 우리가 직접적으로 코드를 변형시킨다던가 하는 조작은 할 수 없지만 API를 통해 간접적으로 일정한 기능을 호출할 수 있다.

### 프레임워크와 라이브러리의 차이점

둘의 개념을 보고도 여전히 차이점에 대해서는 명확히 꼽기 힘들다. 다만 확실한 것은 프레임워크는 단순히 라이브러리의 집합만은 아니라는 것이다.

가장 크게 눈에 띄는 차이점은 바로 환경적인 면이다. 프레임워크는 개발자들의 환경을 제한하는 대신에 일정한 환경을 제공한다.

하지만 라이브러리는 그냥 내가 원하는 코드를 내가 원할 때 원하는 곳에 가져다 넣으면 된다. 여기서 고려해야할 환경은 없고 오로지 의도와 목적성만 존재한다.

그리고 또 **하나는 제어의 주도성을 누가 가지고 있느냐**이다.

이는 자바의 프레임워크 중에 하나인 스프링 관련 저서 **토비의 스프링**에서 참고할 수 있다.

> 라이브러리를 사용하는 어플리케이션 코드는 어플리케이션 흐름을 직접 제어한다. 단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다.
> 반면에 프레임워크는 거꾸로 어플리케이션 코드가 프레임워크에 의해 사용된다.
> 프레임워크에는 분명한 **제어의 역전** 개념이 적용되어 있어야 한다.

여기서 등장하는 용어가 바로 제어의 역전(Inversion Of Control)혹은 제어 역행, IOC라고 부른다. 어렵게 생각할 것 없이 어떤 기능을 불러오고 사용할 때 사용자가 직접하는 것이 아니라 프레임워크가 이 일을 대신하게 된다. 반대로 라이브러리는 그냥 우리가 원할 때 직접 불러올 수 있다. 쉽게 예를 들어본다면 최근 기술적으로 발전하고 있는 자율 운행도 우리가 직접 핸들을 제어하고 조작하는 것이 아니라 자동차 프로그램에서 이를 보정하고 제어하는 것이다. 이 또한 제어의 역전이라고 부를만하다.

하지만 대체 언제 어떻게 프레임워크가 우리 대신에 알아서 이런 기능들을 가져오고 수행한다는 것일까

이때 같이 알아두어야 할 개념이 바로 의존성 주입(Dependency Injection)인데, 줄여서 DI라고 부른다. 여러 객체들간에 의존성이 생기고 이들 의존성을 정리한 BeanContext 정보를 생성하면 이 스프링 컨테이너에서 외부에서 받은메타데이터를 의존성 주입함으로써 제어의 역전을 일으키며 사용자에게 객체를 전달하게 되는 것이다.

이것 또한 쉽게 설명하자면 객체들을 정리해놓은 메타데이터를 외부에서 주입해주는 것이 DI고 이 주입받은 것을 통해서 프레임워크에 의해 코드가 실행되므로 제어의 역전이 일어난다라고만 이해해두면 괜찮다.

- 라이브러리와 프레임워크에 대해 잘못 설명하고 있는 것은

  프레임워크는 전체적인 흐름을 스스로가 쥐고 있으며 사용자는 그 안에서 필요한 코드를 짜 넣는 것이야!
  프레임워크에는 분명한 제어의 역전 개념이 적용되어 있어야돼!
  객체를 프레임워크에 주입하는 것을 Dependency Injection이라고 해!
  라이브러리는 톱, 망치, 삽 같은 연장이라고 생각할 수 있어!

### 가비지 컬렉션이란

정리되지 않은 메모리, 유효하지 않은 메모리 주소인 가비지를 정리해주는 프로그램

Heap 메모리를 재활용 하기위해 참조되지 않는 객체들을 해제시켜 가용한 공간을 만드는 작업

프로그래머가 직접 메모리를 정리하지 않아도 되어 개발 속도가 대폭 향상된다.

메모리를 언제 되찾을 지 결정하기 위한 오버헤드 발생 문제점 존재

### Vector와 ArrayList의 차이는

Vector : 동기식. 한 스레드가 벡터 작업 중이면 다른 스레드가 벡터 보유 불가능
ArrayList : 비동기식. 여러 스레드가 arraylist에서 동시 작업이 가능

### String과 StringBuffer의 차이는

String : 불변. 문자를 수정하려면 지우고 다시 생성해야함 (new) → 문자열 연산이 많으면 기능 떨어짐
StringBuffer : 가변. 한번 만들고 필요할 때 크기를 변경하여 문자를 변경함 (append()와 같이)
StringBuilder : 동기화 지원X. 멀티스레드 환경에 부적합 → 싱글 스레드에서 StringBuffer보다 좋음

- String

String 클래스는 Immutable 객체이기 때문에 + 등 concat 연산 시 원본을 변경하지 않고 새로운 String 인스턴스를 생성해야 하는 단점이 존재한다. 하지만 JDK 1.5 이후부터는 컴파일 타임에 StringBuilder로 변경한다고 한다.

- StringBuilder

String에서 + 등으로 문자열 등을 concat하는 연산이 많은 경우 사용하는것이 좋다. 기존 String 문자들을 concat하는 경우 매번 새로운 String 인스턴스를 사용하기 때문에 성능상의 이슈 존재(JDK 1.5버전 부터는 내부적으로 StringBuilder를 이용하도록 변경되긴 했다.)

- StringBuffer

StringBuffer는 Builder와 비교해서 thread-safe하다. (멀티 스레드 환경에서 동기화의 지원 여부가 다름.) 내부적으로 append 등 모든 메소드에 대해 synchronized 키워드가 붙어있다.

### Serialization이란

- 직렬화. 객체의 상태 혹은 데이터 구조를 기록할 수 있는 포맷으로 변환해줌

### Java의 메모리 영역은 (JVM 을 구성)

- 메소드 / 스택 / 힙 /
- 메소드 : 바이트 코드, 전역 변수, static 변수
- 스택 : 매개 변수, 지역 변수 (사용 끝나면 바로 소멸, 컴파일 시에 메모리 할당)
- 힙 : new로 생성된 객체(c에서는 malloc()). 호출이 끝나도 사라지지 않고 프로그램 실행 시 동적 할당

### 오버로딩과 오버라이딩 차이는

- 오버로딩 : 메소드의 이름은 같고, 매개변수를 다르게 함으로써 여러 메소드를 만드는 것

- 오버라이딩 : 부모클래스로부터 상속받은 메소드를 재정의하는 것. 자식 객체에서 오버라이딩한 메소드는 호출시 오버라이딩한 메소드가 우선시 되어 호출됨 (동일한 리턴타입, 메소드 이름, 매개변수를 가져야함)

### 추상클래스와 인터페이스 차이는

- 추상클래스 : 클래스 내에 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우. extends를 통해 기능을 이용하고 확장하도록 하는 클래스

- 인터페이스 : 모든 메소드가 추상 메소드인 경우 (여러 implements가 가능해 다중 상속 구현 가능) 뼈대만 있으며, 구현하는 모든 클래스에 대해 강제적으로 메소드를 구현하도록 만듬

### 제네릭

클래스에서 사용할 타입을 클래스 외부에서 설정하도록 만드는 것 제네릭으로 선언한 클래스는, 내가 원하는 타입으로 만들어 사용이 가능함
<안에는 참조자료형(클래스, 인터페이스, 배열)만 가능함

### 접근 지정자 4가지

- public : 모든 접근 허용

- protected : 상속받은 클래스 or 같은 패키지만 접근 허용

- default : 기본 제한자. 자신 클래스 내부 or 같은 패키지만 접근 허용

- private : 외부 접근 불가능. 같은 클래스 내에서만 가능

### Java 컴파일 과정 (안드로이드 컴파일 과정 추가)

컴파일러가 소스코드를 자바 바이트 코드(.class)로 변환
JVM이 바이트코드를 기계어로 변환하고, 인터프리터 방식으로 애플리케이션 실행

### C++ 실행 과정

전처리 : #define, #include 지시자 해석
컴파일 : 고급 언어 소스 프로그램 입력 받고, 어셈블리 파일 만듬
어셈블 : 어셈블리 파일을 오브젝트 파일로 만듬
링크 : 오브젝트 파일을 엮어 실행파일을 만들고 라이브러리 함수 연결
실행

### 포인터를 이해하기 쉽도록 설명해주세요

포인터는 메모리 주소를 저장하는 변수임 주소를 지칭하고 있는 곳인데, 예를 들면 엘리베이터에서 포인터는 해당 층을 표시하는 버튼이라고 할 수 있음.
10층을 누르면 10층으로 이동하듯, 해당 위치를 가리키고 있는 변수! 포인터를 사용할 때 주의할 점은, 어떤 주소를 가리키고 있어야만 사용이 가능함

### Annotation

소스코드에 @어노테이션의 형태로 표현하며 클래스, 필드, 메소드의 선언부에 적용할 수 있는 특정기능이 부여된 표현법을 말합니다.

애플리케이션 규모가 커질수록, xml 환경설정이 매우 복잡해지는데 이러한 어려움을 개선시키기 위해 자바 파일에 어노테이션을 적용해서 개발자가 설정 파일 작업을 할 때 발생시키는 오류를 최소화해주는 역할을 합니다.

어노테이션 사용으로 소스 코드에 메타데이터를 보관할 수 있고, 컴파일 타임의 체크뿐 아니라 어노테이션 API를 사용해 코드 가독성도 높여줍니다.

### jvm 역할

JVM은 자바프로그램을 실행시키는 주체입니다.
자바컴파일러는 .java파일을 .class파일인 자바바이트코드로 컴파일합니다.
OS는 이를 이해 할 수 없기에, JVM은 OS가 이를 이해할 수 있도록 도와주며, 따라서 OS에 상관없이 자바프로그램이 구동이 가능합니다.
또한 JVM은 메모리관리, 가비지컬렉션을 수행합니다. (스칼라, 코틀린, 기타 등등)

### jvm 구조

ClassLoader는 자바바이트코드파일인 .class파일을 엮어써, JVM이 운영체제로부터 할당받은 Runtaime Data Area에 적재하는 역할을 합니다.
Excution Engine은 ClassLoder에 의해 적재된 바이트코드들을 기계어로 변경해 명령어 단위로 실행하는 역할을 합니다.
Runtime Data Area는 JVM의 메모리 영역으로 자바어플리케이션을 실행할 때 사용되는 데이터들이 적재된 영익입니다.
GC는 가비지 컬렉터로 참조되지 않는 가비지를 메모리 해제 하는 역할을 합니다.

### CI/CD

- CI
  ‘코드에대한 통합’을 ‘지속적’으로 진행함으로써 품질을 유지하자는 것이다
  층을 하나씩 쌓을때마다 올바르게 지어지고있는지 체크해주는것이 질적, 비용적 측면에서 모두 유리할 것이다.

- CD
  CD란 지속적 배포(Continuous Deploy 또는 Delivery)로써,
  소프트웨어가 항상 신뢰 가능한 수준에서 배포될 수 있도록 지속적으로 관리하자는 개념이다.
  사실 어려울 것 없이 그냥 CI의 연장선으로 생각하면 된다.

### 대용양 트래픽이 갑자기 발생했다. 어떻게 대응할꺼냐

로드 밸런싱 분산처리
데이터 캐싱
지금 회사의 설계에 그 부분이 반영되어 있는가

### 디자인 패턴

여러 사람이 협업을 하며 프로그램을 개발 할 때 다른 사람이 작성한 코드나 기존의 코드를 이해하는 것은 어렵다. 이런 코드들은 유지 보수를 함에 있어서 새로운 기능을 추가하거나 최적화를 하기에 힘든 구조적인 결함을 가지고 있다.
이를 최소화하기 위해서 디자인 패턴은 등장했다. 특수한 경우의 프로그래머가 아니라면 프로그래밍을 하면서 만나는 문제가 지구상에서 유일한 문제일 경우는 거의 없기 때문에 앞서 이미 많은 수많은 오류들을 피하는 방법을 패턴화하게 된다면 좀더 버그가 발생하는 폭을 줄이고 수정하는데(발생하는 숫자가 아니라 예외를 찾는데 조금더 덜 시간을 사용하게 됨) 최소한의 시간을 들일 수 있게 된다.

즉 디자인 패턴은 프로그램 등을 개발하는 중에 발생했던 문제점들을 정리 및 특정한 ‘규약’을 통해 좀 더 쉽고 편리하게 쓸 수 있는 형태로 만든 것이다.

패러다임이나 알고리즘과는 다르며 오히려 코딩 방법론이나 코딩컨벤션에 가깝다고 볼 수 있다.

> 쉽게 말하자면 디자인 패턴은 이미 발견된 오류를 피해 깔려있는 포장 도로와도 같다고 할 수 있다. 우리는 이 포장된 도로를 이용하면서 오류를 최소화하고 시간과 예산 또한 줄일 수 있다.

### 디자인 패턴의 종류

사실 디자인 패턴의 종류는 너무나도 많다. 디자인 패턴만 파고 공부하려면 이 포스트 하나로는 끝나지 않을 정도로 다양한 패턴들이 존재한다. 디자인 패턴을 구체화하고 체계화한 GoF에 의해 디자인 패턴을 각각 생성, 구조, 행위 패턴으로 구분하고 그 하위에 옵저버, 프로토타입, 싱글톤, 프록시, 커맨드, 템플릿 메서드 등 다양한 패턴들이 포함되어 있다.

우리는 이렇게 다양한 디자인 패턴들 중에서 면접에서 왕왕 질문하는 것이기도 하며, 웹이나 앱을 프로그래밍할 때 필연적으로 부딪힐 수 밖에 없는 싱글톤, MVC, MVP, MVVM 패턴들에 대해서 알아보자.

### 싱글톤 패턴

싱글턴 패턴이란 클래스 인스턴스가 하나만 만들어지도록 하고, 그 인스턴스에 대한 전역 접근을 제공한다. 즉, 싱글턴 패턴을 정의한 클래스엔 인스턴스가 최대 1개까지만 생성되고, 어디서든지 이 인스턴스에 접근이 가능하다는 이야기

즉, 이를 구현할 때는 private 생성자와, 정적 메소드, 정적 변수만을 사용한다.

> 싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴

### 그렇다면 대체 왜 전역 인스턴스 하나에 메모리를 할당하여 사용할까

안드로이드 앱 같은 경우에는 각 액티비티나 클래스 별로 주요 클래스들을 일일이 전달하기가 번거롭기 때문에 싱글톤 클래스를 만들어서 어디서나 접근하도록 설계하는 것이 작업하기 더 편하기 때문에 싱글톤 패턴을 자주 사용한다. 또 DBCP(DataBase Connection Pool)처럼 공통된 객체를 여러개 생성해서 사용해야하는 상황에서 많이 사용된다.

캐시나 로그 기록, 사용자 설정 같이 자주 사용되는 데이터들을 같이 공유하며 저장해두는 것들을 생각해보면 이해가 쉬울 것이다.

- 장점

1. 두 번째 이용시부터는 (이미 인스턴스 내에 가지고 있기 때문에)객체 로딩 시간이 현저하게 줄어 성능이 좋아진다.
2. 싱글톤으로 만들어진 클래스의 인스턴스는 전역 인스턴스이기 때문에 다른 클래스들과 데이터를 공유하기가 쉽다.
3. 인스턴스가 절대적으로 한 개라는 것을 보증한다.

- 단점

1. 너무 많은 데이터를 공유할 경우에 인스턴스들 간에 결합도가 높아져 수정이 어려워지고 테스트하기 어려워진다.(객체 지향적인 설계를 지향하기 어려워짐)
2. 멀티쓰레드 환경에서 동기화 처리를 하지 않으면 인스턴스가 두 개가 생성되는 경우가 발생한다.

### MVC 패턴

객체지향프로그래밍에서 MVC란 사용자 인터페이스를 성공적이며 효과적으로 데이터 모형에 관련 시키기 위한 방법론 또는 설계 방식중 하나로써, 목적 코드의 재사용에 유용한 것은 물론, 사용자 인터페이스와 응용프로그램 개발에 소요되는 시간을 현저하게 줄여주는 형식이라고 많은 개발자들이 평가하고 있다.
Model, View, Controller의 약자로 User – View – Controller – Model – Controller – View User의 구조를 가지고 있다.

이 mvc 패턴은 응용프로그램의 시각적 부분과 가 이면의 동작과 제어를 처리하는 부분(비즈니스 로직이라 한다)을 분리하여 서로에 미치는 영향 없이도 응용프로그램을 변경할 수 있다는 장점이 있다.

예를 들어 데이터베이스나 제어프로그램의 변경 없이 시각적인 부분만 수정하려면 view에 해당하는 부분만 수정하면 되고 시각적인 부분과 관계 없이 데이터 처리 부분만 수정하려면 model 부분만, 프로그램간 연결과 제어를 수정하려면 controller 부분만 수정하면 되는 방식이다.

- M(Model)

애플리케이션의 정보(데이터)를 처리하는 컴포넌트를 말한다. 다시 말해 데이터베이스에 연결하고 데이터를 추출하거나 저장, 삭제, 업데이트, 변환 등의 작업을 수행하는 역할을 한다.

> 데이터를 처리하는 역할

- V(View)

View는 말그대로 화면에 표시되는 부분이다. 추출한 데이터나 일반적인 텍스트 데이터를 표시하거나 input, button등의 사용자 인터페이스 요소, 데이터 및 객체의 입력, 출력 또는 사용자와의 상호작용을 위한 인터페이스를 표시하는 영역이다. 담당하는 사용자가 볼 수 있는 화면이다.

> 사용자가 보는 화면

- C(Controller)

Controller는 어플리케이션에서 각 요소들의 연결관계를 설정하고 데이터와 시각적 부분의 연결 등을 관리한다. 대개 url로부터 입력되는 정보로부터 어떤 데이터와 뷰를 연결할 지 등을 제어한다.

사용자가 Controller에 작업을 요청하면 Controller는 Model을 호출하여 데이터를 처리하고 Model이 데이터를 처리한 결과를 View에 보내고 이 결과를 사용자가 보게 된다는 것이다.

Model과 View를 이어주는 다리 역할, 모든 “이벤트”를 처리하는 부분, 메인 로직을 담당. Model과 View를 연결하고 있는 클래스를 대표, Model과 View 내의 클래스들 간 정보 교환하는데 사용한다.

> 데이터와 뷰를 연결, 제어하는 역할

### MVC패턴의 장/단점

- 장점

1. 전형적인 어플리케이션 OOP 구조로써 가장 단순하며 보편적으로 많이 사용하는 디자인 패턴
2. 맡은 일에만 집중할 수 있게 되기 때문에 효율성을 높이고 유지보수가 편리해지고, 애플리케이션의 확장성과 유연성이 늘어나고, 중복코딩의 문제점이 사라진다.
3. 유저 인터페이스와 비지니스 로직 분리

- 단점

1. View와 Model 사이의 의존성이 높다. 따라서 어플리케이션이 커질수록 복잡하고 유지보수가 어려워질 수 있다.

### MVP 패턴

앞서 MVC패턴을 설명하며 View와 Model 사이의 의존성이 높고, 이 의존성이 높기 때문에 어플리케이션이 커지면 커질 수록 더 복잡해지고 유지보수가 힘들어진다는 단점을 가지고 있다고 했다. 이런 MVC패턴의 한계점 때문에 이를 기반으로 해서 한계점들을 극복하기 위한 현대의 다양한 패턴들이 있다. MVP패턴도 바로 그 중에 하나인데, MVP는 Model-View-Presenter의 약자로 Model과 View는 MVC와 동일하지만 Controller 대신에 Presenter가 존재한다.

위 사진처럼 MVC와 다르게 컨트롤러 대신에 Presenter가 View와 Model 사이를 중계해주고 있다. 따라서 Model과 View는 서로를 알 필요가 전혀 없이 Presenter만 가리키게 된다. 따라서 View와 Model의 의존성은 사라지게 된다.

사용자들의 입력들은 View를 통해서 데이터를 Presenter에 요청하고 Presenter는 Model에게 데이터를 요청한다. Model은 Presenter에게 응답해서 다시 View로 전송해서 화면에 나타내게 되는 동작 순서를 가지고 있다.

모델은 위 MVC패턴과 동일하며 뷰와 프리젠터에서 구성 요소의 변화가 있다.

- V(View)
  기본적으로는 MVC와 같이 화면에 보여지는 요소를 맡는 것은 동일하나 Controller가 사라짐에 따라서 이제 사용자의 입력을 받는 역할을 겸하게 된다. MVC에서 Controller의 역할의 일부를 얻게 되었다고 이해하면 좋다.
- P(Presenter)
  View에서 요청한 정보로 Model을 가공하여 View에 전달해주는 부분이다. 본질적으로는 MVC의 컨트롤러와 같지만 뷰에 연결되는 것이 아니라 그냥 인터페이스라는 점이 다르다.

### MVP패턴의 장/단점

- 장점
  MVC와 달리 View와 Model의 의존성이 사라졌다.
- 단점
  View와 Model 사이의 의존성은 해결되었지만 대신에 View와 Presenter 사이에 높은 의존성을 가지게 되었다. 이는 MVC와 마찬가지로 어플리케이션이 복잡해질수록 View와 Presenter 사이의 의존성이 더욱 강해지고 복잡해진다.

### MVVM 패턴

이쯤되면 어느정도 감이 올수도 있는데, View와 Model의 의존성이 없는 대신에 View와 Presenter가 의존성이 생겨버리고 그로인한 문제점을 극복하기 위해서 등장한 패턴이 바로 MVVM이다.

MVVM은 Model - View - ViewModel의 약자로 이번에는 MVP와 다르게 Presenter 대신 ViewModel이 존재한다.

- VM(ViewModel)
  뷰에 필요한 데이터를 준비하고 모델에 필요한 이벤트를 전달한다. 그러면서도 뷰에 종속되지 않는 뷰만을 위한 모델이라고 할 수 있다.

여기서 궁금증이 들 수 있다. 어떻게 뷰와 뷰모델, 뷰모델과 모델간에 의존성이 사라지게 되느냐. 그것은 바로 Command패턴과 Data Binding 덕분인데, 이 패턴과 라이브러리로 인해서 의존성이 완전히 사라지게 된다.

Command패턴과 Data Binding은 각각 또 하나의 문서를 할애해서 설명이 필요할 만큼이나 긴 설명이 필요해서 해당 포스팅의 목적과 엇나갈 수 있으므로 간략하게만 짚고 넘어가자.

- Command패턴은 앞서 설명한 여러가지 디자인 패턴들 중에 하나이며 요청을 객체의 형태로 캡슐화하여 저장, 로깅, 취소를 할 수 있는 패턴이다.
- Data Binding은 XML에 만든 View들을 자동으로 알아서 만들어주는 안드로이드 라이브러리이다.

요약하자면 여전히 MVP패턴처럼 View를 통해 사용자의 입력이 들어오게 되면 Command패턴으로 ViewModel에 요청한다.
ViewModel은 Model에게 필요한 데이터를 요청하고 Model은 응답한뒤 ViewModel에서 다시 가공해서 저장한다.
여기서 View로 다시 안돌려주냐고 할 수 있는데, View는 Data Binding을 통해 자동으로 갱신하게 된다.

### MVVM 패턴의 장/단점

- 장점

1. Command 패턴과 Data Binding을 사용하여 View와 Model, 심지어 View와 View Model 사이의 의존성 또한 없앴다.
2. 테스트와 모듈화가 쉽다
3. 뷰와 모델을 연결하기 위해 사용해야 하는 연결 코드를 줄일 수 있다.

- 단점

1. View Model의 설계가 쉽지 않다.
2. 뷰가 변수와 표현식 모두에 바인딩될 수 있어서 시간이 지남에 따라 관계없는 프리젠테이션 로직이 늘어나 유지 관리하기 번거롭다.
